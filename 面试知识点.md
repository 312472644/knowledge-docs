[TOC]

题目来源：https://juejin.cn/post/6905294475539513352

### HTML

------

1. src和href有什么区别？

   ```
   src：表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本，浏览器遇到src会暂停其他资源下载，等到该资源下载完成，在进行其他资源的下载，会阻塞DOM的解析。
   href：表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。不会阻塞DOM的解析。

2. script标签中defer和async的区别？

   ```
   defer和async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析。
   defer：按照顺序加载。加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行。
   async：不能保证加载的顺序。表示后续文档的加载和执行与js脚本的加载和执行是并行进行的。

3.  Canvas和SVG的区别。

   ```
   SVG:SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言。它不依赖分辨率，支持事件处理器适合大型渲染区域。
   Canvas:Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。它依赖分辨率，不支持事件处理器，能够以.png 或.jpg 格式保存结果图像。

4. 渐进增强和优雅降级之间的区别。

   ```
   渐进增强:主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。
   优雅降级:一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。
   ```

5. 对盒模型的理解。

   ```
   盒模型分为标准盒模型和IE盒模型。其中盒模型组成部分都是content、border、padding、margin四部分组成。可以通过box-sizing(content-box:标准盒模型(默认值)。border-box:IE盒模型)属性来改变盒模型。
   标准盒模型：元素的width和height只包含了content。
   IE盒模型：元素的width和height包含了padding、border、margin。

6. 

### CSS

------

1. CSS选择优先级。

   ```
   内联样式>ID选择器>类选择器、属性选择器>标签选择器>通配选择器*

2. display的block、inline和inline-block的区别。

   ```
   block:会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；
   inline:元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；
   inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。

3. link和@import的区别。

   ```
   1、link在页面载入时同时加载。@import等到页面加载完成才加载。
   2、link支持JavaScript改变样式，@import则不行。
   3、link是XHTML标签，无兼容问题，@import低版本浏览器不兼容，存在兼容性问题。

4. 对BFC的理解，如何创建BFC。

   ```
   BFC成为块级格式上下文。BFC可以理解为是一个容器，它里面的内容不会影响到其他环境的内容。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受到外界的影响。
   触发BFC的条件：元素设置为浮动(float)、绝对定位、display等。其作用是解决高度塌陷的问题和margin的重叠问题、创建自适应两栏布局。
   ```

### JavaScript

------

##### 数据类型

1. JavaScript有哪些数据类型，它们的区别？

   ```
   String、Number、Boolean、Null、Undefined、Symbol、Object。
   这些数据类型可分为基本数据类型和复杂数据类型。基本类型存储在栈(stack)中，而复杂数据类型则存储在堆中。这两种数据类型的区别其实就是堆栈的区别。
   栈：存放的是基本数据类型的值。数据结构为采用先进后出的队列。栈区内存由编译器自动释放。
   堆：存放的是复杂数据类型在栈中的引用地址。数据结构为采用先进先出的队列。堆区内存一般由开发者手动释放，如果开发者未释放，就由程序GC机制回收。
   ```

2. 数据类型的检测方式有哪些？

   ```
   typeof：检查数据的类型。
   instanceof：检查该对象是否在原型链上。
   Object.prototype.toString.call()：使用Object原型上的toString方法来检测基本类型。
   ```

3. isNaN和Number.isNaN函数的区别？

   ```
   两个方法都是用来判断是否不为Number类型。如果不是Number类型，返回true，反之则为false。
   isNaN：该方法对传入的参数会将其转化成Number类型，然后再去判断。
   Number.isNaN：该方法会对传入的参数判断是否为Number类型，不会进行数据的转化。然后再去判断。相比于isNaN判断更准确一点。

4. 为什么0.1 + 0.2 != 0.3，如何让其相等？

   ```
   计算机是通过二进制的方式存储值。0.1 + 0.2的和其实就是计算两个二进制数据之间的和。所以就造成了偏差。可以借助Number.EPSILON对象，该对象是设置一个误差范围，表示在该误差范围内是有效的。

5. 装箱和拆箱的区别。

   ```
   1、将基本类型转化成对象类型称之为装箱。装箱会产生一个临时对象，对性能会有影响。
   2、将对象类型转化为基本类型称为拆箱。在拆箱过程中会默认执行ToPrimitive方法，具体转化规则如题6。
   
6. JavaScript 中如何进行隐式类型转换？

   ```
   调用一个叫ToPrimitive(obj,type)的方法。首先判断数据类型是否为基本数据类型，如果是基本数据类型，则直接返回。如果不是，则根据该方法的type类型来返回。
   1、如果type为Number类型。首先调用valueOf方法，判断是否原始类型的值返回，如果有则返回。如果没有就调用toString方法，判断是否有值，有则返回，没有则抛出TypeError的异常。
   2、如果type为String类型。首先调用的是toString方法。逻辑同上。

7. Object.is() 与其他比较操作符 “==” 和 "===" 的区别？

   ```
   ==：简单比较数据值是否相等。
   ===：比较数据值是否相等的同时比较数据类型是否相等。
   Object.is()：和"==="判断类似。只不过判断+0与-0不相等。isNaN与isNaN是相等的。

##### JavaScript基础

1. new 操作符的实现原理。

   ```
   1、创建一个新对象。
   2、将新对象的_proto_属性设置为函数的原型对象。
   3、将构造函数的this指向该对象。并执行函数。
   4、判断函数返回值。如果函数返回的是引用类型，那么返回该对象。如果不是，那么就会创建的对象。

2. Map和Object、weakMap的区别？

   ```
   Map和Object都是采用键值对的方式存储数据。
   Map：属性可以是任意数据类型。读取属性的值，能够有序的属性的值。在频繁的删除或插入键值，Map是有做过性能优化。
   Object：属性只能是string和symbol类型。读取属性的值，是无序的，无法保证顺序。
   WeakMap:作用和Map差不多。但是WeakMap的键值只能是对象，且对对象是一种弱引用。当对象的其他引用被清除掉，WeakMap里面的键名和对应的对象会自动被删除，无需手动释放。
   ```

3. 对类数组对象的理解，如何转化成数组？

   ```
   一个拥有length属性和若干索引属性的对象称为类数组。类数组不能调用数组的方法。可以用过Array.From()方法将其转化为数组。

4. espace、encodeURI、encodeURIComponent区别？

   ```
   espace:会对传入的参数进行编码。如果只是字符串编码采用该方法。
   encodeURI和encodeURIComponent都是一种编码方式。只是encodeURIComponent编码范围比encodeURI更大。如果需要对整个URL编码，且需要使用该URL，那么就用encodeURI。如果需要对URL传参编码，那么就使用encodeURIComponent。

5. 对于Ajax的理解，实现一个Ajax请求。

   ```
   1、创建一个XMLHttpRequest对象xml。
   2、调用xml.open()方法。该方法提供请求类型以及请求地址。
   3、调用xml.send()方法。如果是post请求，send方法里面可以传递参数。
   4、监听onreadystatechange事件。当状态state为4且http状态码为200，表示请求已经完成且成功。然后可以进行其他逻辑性处理。
   ```

6. 对原型、原型链的理解。

   ```
   原型：JavaScript中的构造函数都会有一个prototype属性，该属性值就是构造函数的原型对象。该对象包含了构造函数所有共享的属性和方法。当通过构造函数创建实例时，实例中会有一个_proto_属性指向构造函数的原型对象。那么这个指针就成为原型。
   原型链：当我们访问对象上的某个属性时，会首先从其构造函数自身的属性上去查询是否有该属性，如果不存在，就去构造函数的原型对象上查找。而构造函数的原型对象可能继承了其他函数，这样一层一层的往上查找。如果查到就返回，否则就返回undefined。这样查找的过程称为原型链。

7. 对闭包的理解。

   ```
   闭包就是一个函数当中嵌套另外一个函数，且嵌套函数引用了该函数中的变量，并返回该函数。
   闭包的主要作用有两个。一个就是可以访问函数内部的变量的值。另外一个就是可以将函数变量的值保存在内存中。因为调用函数中还存在对闭包函数的引用，所以不会立即释放。但是过多使用闭包且不及时释放，有可能会导致内存泄漏。

8. 对作用域、作用域链的理解。

   ```
   作用域分为全局作用域和函数作用域。
   全局作用域：最外层的作用域。所有未定义直接赋值的变量自动声明为全局作用域。
   函数作用域：作用域是分层的，内层作用域可以访问外层作用域，反之不行。
   作用域链：在当前作用域中访问变量时，会从函数内部查找，查不到就往父级作用域中查找。直至到window对象。这样查找的过程就是作用域链。作用域链保证了执行环境对函数的权限访问和变量的有序访问。

9. 对执行上下文的理解。

   ```
   分为全局执行上下文、函数执行上下文、eval执行上下文。每个上下文都包含了活动对象、作用域链、以及this对象。且执行上下文都包含了活动对象，作用域链(scope)，this这三个属性。
   当函数代码被执行的时候，会创建一个全局执行上下文，并将全局上下文放到执行栈中。当遇到函数调用时，就会创建函数执行上下文，并将当前函数放到执行栈的顶部。当该函数执行完成后，就会从执行栈中弹出。直到所有代码都执行完毕，最后才将全局执行上下文中弹出。
   ```

10. 对this对象的理解。

    ```
    this是执行上下文中的一个属性。this指向分为以下几种情况。
    1、默认指向是window
    2、调用new关键字调用时，this指向创建的实例
    3、调用apply、call、bind等方法时，this指向传入的参数对象。
    4、调用对象属性里面的方法时，this指向该对象。

11. 实现call、apply、bind函数。

    ```
    实现call函数。
    1、判断参数是否为函数，如果不是函数就抛出异常
    2、判断是否有上下文对象，如果没有则设置为window
    3、获取传入参数
    4、将函数作为上下文对象的一个属性
    5、执行该上下文对象属性，并保存返回结果
    6、删除该属性
    7、返回结果
    apply和call实现原理差不多，只是传参不一样。bind函数只需要返回一个新的函数即可。

12. 浏览器垃圾回收机制。

    ```
    当JavaScript运行中，需要分配内存空间来存储变量和值。当变量不在参与运算后，就会被回收，以达到释放内存的目的。这就是垃圾回收。
    浏览器垃圾回收机制主要使用两种方式。
    1、清除标记。当变量进入执行环境时，就会打上一个标记(进入环境),表示当前变量正在使用，无法清除。当变量离开执行环境时，就会被标记为(离开环境)，离开环境的标记就自动被清除，并被内存释放。
    2、引用计数。跟踪记录每个值被引用的次数。当一个变量被赋值另外一个引用类型变量时，该值引用计数就会加1。相反，当该变量的值发生改变时，该值的引用计数就会减1。当该值引用计数变为0时，该值就会从内存中释放。

13. 解释性语言和编译性语言的区别。

    ```
    解释性语言：无法在机器上直接运行，需要由解释器将代码编译成机器码之后在执行。常见的解释性语言有JavaScript、Python等。每次执行代码都需要编译一次，执行效率相比于编译性语言要低一些。编译后直接在该平台运行，运行速度快。
    编译性语言：需要由编译器编译后，能在机器上直接运行。编译后的代码会生成一个可执行文件。如.exe等。以后要执行代码时，直接执行编译后的文件即可，无需每次编译。运行期间才编译，跨平台性好。

14. JavaScript执行过程是怎样的？

    ```
    执行过程可分为三个过程。
    1、词法拆分：将js代码拆分为字节流(token)，加入到一个AST数组中
    2、语法分析：分析AST数组，检查是否有语法错误。如果有错误，就抛出语法异常，没有就执行下一步
    3、代码生成：将AST转化成机器可执行的机器码，并执行代码

15. 前端模块化的理解。

    ```
    AMD：requireJS是基于该规范实现。依赖前置(提前加载)。依赖的函数会立即下载并运行，相对于seaJS用户体验更好。
    CMD：seaJS是基于该规范实现。就近依赖(按需加载)。依赖函数会下载，但不会立即执行，等到需要它的时候才会运行。相对于requireJS性能更好。
    CommonJS：node是基于该规范实现。是一个同步的加载模块。
    ES6：ES6模块语法。提供export和import导出和导入模块。

16. require和import的区别。

    ```
    1、require是CommonJS模块语法。import是ES6模块语法。
    2、require是运行时加载。import是编译时加载。
    3、require通过module.exports导出是一个模块对象。import通过export导出的是指定的代码。
    4、require通过module.exports的值不会发生改变(导出的是值的拷贝)。import通过export导出的值是会发生改变的(导出的值是引用类型)。
    ```
    
17. 为什么函数的arguments参数是类数组而不是数组？

    ```
    函数的arguments是一个对象，它的属性是从0开始依次递增的，有callee和length等属性，与数组相似；但是没有数组常见的属性。不能直接遍历。

18. requestAnimationFrame的理解。

    ```
    requestAnimationFrame是浏览器用于定时循环的一个接口。主要用于网页按帧重制。相比于setTimeout它具有以下有点。
    1、它会把每一帧中所有的DOM操作集中起来，在一次重绘或重排中完成。并且重绘或重排的时间紧跟浏览器的刷新频率。
    2、当页面未被激活时，页面的刷新机制也会被停止。当页面激活时，页面刷新机制会从上次暂停的地址继续开始。
    缺点：兼容性不好
    ```
    
19. 常见的函数式编程方法。

    ```
    纯函数：相同的输入永远得到相同的输出。比如React中的高阶组件就是一个纯函数。
    柯里化：将多元函数拆成一元函数。
    函数组合式：将上一个函数执行的结果当做参数传递给下一个函数，由多个函数组合而成，这样当某个函数报错时，能更快的定位到错误信息。比如Webpack中loader的加载顺序就是通过这样的方式加载的。
    ```
    
20. 装箱和拆箱的区别。

    ```
    1、将基本类型转化成对象类型称之为装箱。装箱会产生一个临时对象，对性能会有影响。
    2、将对象类型转化为基本类型称为拆箱。在JS会默认做拆箱处理。

##### ES6

1. let、const、var的区别。

   ```
   var：存在变量提升，会导致相同名称的值被覆盖。
   let：不会存在变量提升。有块级作用域，在同一个块级作用域下，声明相同的变量，会报错。
   const：定义一个常量。作用和let差不多。如果定义的值是基本数据类型，那么该变量时不可被修改的。如果是复杂数据类型，对象里面的属性值是可以被修改的。因为const定义常量不变的是对对象引用的地址，而不是值不变。
   ```

2. 箭头函数和普通函数的区别？

   ```
   普通函数：1、能够使用new关键字来实例化对象。2、可以改变this的指向。
   箭头函数：1、不能作为构造函数使用 2、没有原型对象。3、this指向不会改变，即使使用apply、call、bind方法。

##### 异步编程

1. 异步编程的实现方式？

   ```
   1、函数回调方式。语法不够简洁，且会造成地狱回调。
   2、Promise。本质是上函数回调的升级版，只是改变回调的方式，通过使用then方法链式调用。如果嵌套请求层次过多，也会造成语义不明确，不便于调试。
   3、generator。通过控制函数的执行权的方式，来实现异步编程。当遇异步函数时，将函数执行权转交给异步函数，等到该函数执行完成，在将控制权收回，继续执行后面的代码。需要一个自执行机制。
   4、async/await。基于promise和generator实现的一种语法糖。当async函数遇到await关键字时，会等待await后面函数执行完成后，在继续执行后面的代码。
   ```

2. 对Promise的理解。

   ```
   Promise是一种异步解决方案。Promise有三个状态pending、resolve、reject。且只能从pending到resolve或pending到reject。一旦状态改变就不会改变。
   Promise有以下缺点。
   1、无法取消请求
   2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部

### Vue

------

##### Vue基础

1. Vue的基本原理。

   ```
   当创建一个实例时，Vue会遍历data中的属性，通过使用Object.defineProperty方法将data中的属性转化成getter/setter，并在内部记录相关依赖。每一个组件实例都有对应的watcher实例。当data中的属性值发生变化时，就会通知watcher实例，使其对应的组件更新。

2. 双向绑定的原理。

   ```
   采用数据劫持和发布订阅的设计模式。通过Object.defineProperty来劫持各属性的getter，setter，当数据发生改变时，会发送消息给订阅者，触发相应的回调。可以分为以下几个步骤。
   1、对需要监听的数据进行递归遍历，添加对应的getter和setter。
   2、complie解析模板指令，将每个指令进行解析，并添加对应的订阅者。
   3、组件对应的watcher实例充当订阅者的角色。当监听的数据属性值发生改变时，这时候就会触发setter或者getter方法，通知对应的订阅者，然后对应的组件进行更新。

3. MVVM、MVC的区别。

   ```
   MVC:M表示Model层，用来存储页面交互的数据。V表示View即视图层。C表示Controller即控制层，用来处理业务逻辑。用户通过View视图触发事件，通知Controller，然后Controller处理完成后，通知到Model，最后由Model层通知到View层，实现视图更新。
   MVVM：M表示数据模型层。用来定义数据模型。V表示视图层。VM是ViewModel。是用来链接Model层和View层的桥梁，当View层发生变化通过ViewModel也会引起Model层的改变。反之Model层改变也会通过ViewModel引起View的改变。

4. Computed、Watch、Methods的区别。

   ```
   Computed:计算属性。Computed的值具有缓存。只有当依赖的值发生变化时，才会重新执行。不支持异步。
   Watch:监听器。不具有缓存。当监听的数据发生改变时，会触发watch对象里面的方法进行回调操作。支持异步。
   Methods:和计算属性差不多。但是Methods方法总是会调用执行。

5. slot作用以及原理。

   ```
   slot分为匿名插槽、具名插槽、作用插槽。
   匿名插槽：默认的插槽。
   具名插槽：通过指定slot的name属性，可以在指定的地方插入内容。
   作用插槽：通过将子组件的值传递父组件，以此来自定义插槽的渲染内容。
   当组件被vm实例化时，会生成一个vm.$slot的对象，该对象就是插槽对象。默认就是vm.$slot.default匿名插槽。具名插槽就是vm.$slot.name(定义的插槽name)。在视图渲染时，此时可以传递参数，这就是作用插槽。然后再slot对象替换成插槽的内容即可。

6. data为什么是一个函数而不是一个对象？

   ```
   为了解决数据混乱的问题。在组件内部，如果data是一个对象，当引用该组件改变data里面某个属性的值时，其他引用改组件的data值也会也会发生变化。如果是一个函数，就相当于是值引用，不会造成数据混乱的问题。

7. $nextTick原理及作用。

   ```
   $nextTick是利用promise、setTimeout等异步方法来模拟对应的宏/微任务的实现。用来实现异步队列的回调。它的作用就是某些场景需要进行DOM操作时，就使用该方法。引入异步队列的原因其实比较简单就是为了性能优化，如果是同步的话，对一个值多次赋值，会频繁的触发UI/DOM渲染，造成没必要的性能浪费。

8. 单页面(SPA)与多页面(MPA)的区别。

   ```
   SPA:单页面应用程序。只有一个主页面，所需的公共资源文件只需要加载一次。页面的跳转利是用前端路由跳转，因此页面是局部刷新的。用户体验好，但是不利于SEO。
   MPA:多页面应用程序。多个页面，每次页面跳转都会重复加载公共的资源文件，且会刷新页面，用户体验不好。但是利于SEO。
   ```

9. Vue data中某个一个属性值发生改变后，试图会立即更新吗？

   ```
   不会立即更新。Vue的DOM更新是异步的，只要监听到数据的变化，就会开启队列，并将其加入到队列中，同一个属性发生多次改变，只会添加一次进入队列(去重)。来达到性能优化的目的。等到下一次事件循环tick，就会执行去重后的代码。

10. 对React和Vue的理解，它们的异同。

    ```
    数据流：Vue双向数据流。React单向数据流。
    虚拟DOM：
    	Vue：当组件属性发生变化时，不需要渲染整个组件，只渲染改变部分。
    	React：当组件属性发生变化时，整个子组件会重新渲染。
    监听数据变化：
    	Vue：采用数据劫持-发布订阅的模式。
    	React：比较数据之间的引用是否发生改变，
    组件化：
    	Vue：template模板，更加贴近HTML原生写法。
    	React：JSX语法。
    ```

11. Vue 模板编译原理。

    ```
    分为三个阶段解析阶段、优化阶段、生成阶段。
    解析阶段：使用正则表达式将template转化成AST树。
    优化阶段：遍历AST树，对于静态节点打上标记，在diff算法中，打上静态标记直接跳过。
    生成阶段：将优化后的AST转化成render函数。
    ```
    
12. Vue的优缺点。

    ```
    优点：
    1、双向绑定
    2、提供响应式和组件化视图
    3、使用虚拟DOM
    4、轻量级框架
    缺点(相比于react):
    1、JSX与template。JSX语法可以使用完整的JS语法来构建页面。比如可以使用临时变量、条件控制语句等。
    2、原生渲染。React Native 相比于 week 更加成熟。
    ```
    
13. Vue 是如何收集依赖的？

    ```
    初始化vue组件实例时，会对组件中的data进行数据劫持，为每个data属性添加对应的getter/setter，其中getter部分就是用来收集依赖的。收集依赖主要有两个类Dep和Watcher。Dep类的主要作用是添加订阅者和发布消息，Watcher类作用就是收集相关依赖。每个组件都会有一个watcher实例，当实例化这个对象时，会触发构造函数中的get方法，该方法的作用就是将当前的watcher订阅到Dep的订阅列表中。当监听数据发生变化时,会触发Dep中的notify方法，然后通知对应的订阅者，实现对应的操作。
    ```
    
14. 如何理解Vue渐进式框架？

    ```
    所谓的渐进式主张问题少，没有那么多的硬性要求。Vue可以逐渐增强使用，可以单独在网页中局部使用vue.js或者可以全局使用工具搭建vue项目。可以根据项目需求不同来添加不同的部件，如果路由，状态管理等且这些部件相互独立，不会耦合在一起。相比于React和Angular，Vue的主张更少，比如React主张函数式编程，Angular主张模块机制和依赖注入等。

##### 生命周期

1. Vue生命周期有哪些。

   ```
   beforeCreated:组件实例创建之前。
   created:组件实例创建完成。此时渲染节点还未挂在到DOM，不能访问虚拟DOM。
   beforeMounted:开始挂载之前。render函数首次被调用，能够访问到虚拟DOM。
   mounted:挂载完成。将虚拟DOM替换成真实的DOM。可以访问到真实的DOM元素。
   beforeUpdate:组件更新之前。组件虽然更新了，但是真实的DOM还未被渲染。
   updated:更新完成。组件的DOM更新完成。
   beforeDestroy:组件销毁之前。能够访问到this对象，可以在此生命周期做一些释放对象内存的操作。
   destory:组件完成销毁。

##### 组件通信

1. 组件的通信方式有哪些。

   ```
   父传子：1、通过属性传递。2、父组件通过$ref获取子组件实例，同样子组件也可以通过$parent来获取父组件实例。
   子传父：子组件通过emit触发事件，父组件监听事件。
   跨组件传参：
   	1、事件总线。定义一个vue实例，触发事件，监听事件即可。
   	2、provider、inject
   	3、vuex store传递参数。

##### 路由

1. 路由hash和history模式的区别。

   ```
   hash：通过监听onhashchange事件去监听hash是否发生变化来实现对应的内容切换。hash值会出现在url里面，但是不会出现在http请求中，因此修改hash值不会重新加载页面。
   history：通过监听onpopstate事件来实现该路由。修改url，服务端会重新解析这个请求，因此服务端需要做一些配置。比如用户输入错误的地址，如果没有做出相应配置，那么页面就会报错了。
   ```

2. 路由的传参方式以及区别。

   ```
   1、query方式传参。通过$route.query获取。这种方式传参参数会出现在url中，刷新页面参数不会消失。
   2、param方式传参。通过$route.param获取。这种方式参数是通过body传递过去，不会出现在url中，刷新页面参数会丢失。

3. Vue-Router钩子有哪些？

   ```
   1、全局导航
   	beforeEach:进入路由之前。可以用该钩子实现登录拦截功能。
   	afterEach:进入路由之后。
   2、路由导航。
   	beforeEnter:如果不想配置全局导航，可以在路由导航里进行单独配置。
   3、组件导航。
   	beforeRouteEnter：进入组件之前触发的钩子。
   	beforeRouteLeave：离开组件触发钩子。
   	beforeRouteUpdate：路由改变时触发的钩子。比如路由参数发生变化等。
   ```

##### Vuex

1. Vuex的原理以及理解。

   ```
   vuex是一个状态管理的工具。其中vuex包含以下几个属性。
   state:用来定义store数据。
   commit：状态改变提交数据的方法。对mutation进行提交，是唯一能提交执行mutation的方法。
   mutation：Vuex推荐唯一能改变state数据的方法。该操作是同步的。
   action：支持异步操作改变state属性。action提交的是mutations，而不是直接改变状态。
   dispatch：操作行为方法。唯一能执行action的方法。
   getter：类似于computed属性，通过对state进行处理，返回处理后state数据。
   
   tips：可以通过mapState、mapGetter、mapMutation、mapAction来帮助我们调用vuex store。

2. Vuex和单纯的全局对象有什么区别？

   ```
   Veux是响应式。当store state里面的值发生改变时，视图也会做出响应的变化。而全局对象则不会。
   在非严格模式下是可以直接改变store的状态。但是这样会造成无法跟踪每一个状态的变化，当报错时，不便于调试。所以不推荐直接改变store的状态。

3. 为什么Vuex的mutation中不能做异步操作？

   ```
   Vuex改变状态的唯一途径都是mutation。异步操作Action也是通过提交mutation来改变状态。这样更加方便我们追踪每个状态的变化，便于调试。如果mutation支持异步操作，那么就无法区别是由Action 提交的mutation还是由commit提交mutation。

##### 虚拟DOM

1. 对虚拟DOM的理解？

   ```
   虚拟DOM其实就是一个JS对象，用来描述真实DOM结构的对象。配合不同渲染的工具，使跨平台具有可能性。通过处理事务机制(比如异步队列)，将多次的DOM修改的结果一次性渲染到页面上，而不用大量去操作DOM元素，引起不必要重绘和重排，提高性能。但是虚拟DOM的效率不一定比修改DOM要高，这个要看场景区分。比如只是修改一个div的文本信息，肯定是用直接操作DOM修改要快的，因为虚拟DOM还要经过Diff算法，才能渲染到页面上。
   缺点：对于一下性能要求较高的项目无法进行极致优化。

2. 虚拟DOM解析过程。

   ```
   1、解析文档的DOM结构，用JS对象将其保存起来。
   2、当页面状态发生改变之后，根据改变后的状态，新建一个对象树，然后与之前的对象树进行比较。记录其差异。
   3、将其差异的对象树转化成真实DOM树。

3. Vue Diff算法的原理。

   ```
   1、不做跨级层次节点不做比较。
   2、如果父节点不同，则放弃比较子节点，直接删除旧节点然后添加新的节点重新渲染。
   3、如果子节点有变化，虚拟DOM不会计算变化时什么，而是重新渲染。
   4、同级多个节点比较通过唯一key比较异同。

4. Vue中key的作用。

   ```
   1、强制渲染。在v-if，如果切换的是相同类型的元素，那么这个元素就被复用。如果添加了key，这个元素就被标记为唯一，在此切换组件，就不会被复用了。
   2、提高虚拟DOM渲染效率。在v-for中使用key，相当于为每个元素添加了唯一标识。当数组发生改变，Diff算法直接通过key找到每个元素，而不用去遍历递归，从而提高虚拟DOM渲染效率。

### React

------

##### 组件基础

1. React的事件机制。

   ```
   React事件是合成事件，并不是将事件绑定给到真实的DOM上，而是在document上监听了所有事件，当事件冒泡至document时，React将事件内容交给真正的函数去处理。这样做的好处为了减少内存和在组件销毁的时候取消事件的订阅。冒泡至document事件不是原生事件，而是React的合成事件。使用合成事件的好处跨浏览器，统一事件处理机制。因此要阻止事件冒泡不能使用event.stopPropagation, 而是使用event.preventDefault。

2. 对React-Fiber的理解，它解决了什么问题？

   ```
   Fiber是React 16中新增的一种核心算法。它的作用支持虚拟DOM的增量渲染。在之前的版本中，渲染是，需要通过diff算法找出变动的节点，同步更新它们。这个过程React会占住浏览器资源，用户触发的事件得不到响应，会出现卡顿现象。所以React通过fiber，让这个过程变得可中断、暂停、继续，在适当的时候将控制权让给浏览器，让浏览器执行优先级更高的任务，等到浏览器空闲时，在恢复执行暂停的任务。这样浏览器就能及时响应用户的操作了，提高了用户的体验。

3. React.Compoent和React.PureComponent的区别。

   ```
   React.Compoent：表示一个组件。
   React.PureComponent：表示一个纯组件。它默认的执行了shouldUpdate生命周期，将数据进行浅比较，判断组件是否需要重新渲染。从而减少组件render的次数，达到提高组件性能的目的。
   ```

4. React 高阶组件是什么，和普通组件有什么区别，适用于什么场景？

   ```
   React高阶组件本质上是一个函数。通过将其他组件当参数传递进去，进行逻辑操作后，返回一个新的组件。
   HOC的好处：
   1、代码复用、逻辑抽象
   2、渲染劫持。比如可以通过HOC实现一个显示错误的组件，当页面报错，就会被该组件拦截，然后对错误信息进行处理。

5. 哪些方法会触发React重新渲染？重新渲染会做什么？

   ```
   1、调用setState方法。 调用setState会触发render函数，但是执行setState不一定会触发render，比如setState(null)时，就不会触发render。
   2、父组件重新渲染。只要父组件重新渲染，那么子组件全部会重新渲染，即使父组件传递给子组件参数未发生变化。
   重新渲染时会进行diff算法。首先会比较新旧VNode树，然后递归遍历新旧树，将其差异放入到一个对象中，最后遍历差异对象，根据规则去更新对应的VNode。

6. React如何判断什么时候渲染组件？

   ```
   组件可以通过改变props或通过setState方法来改变状态。只要组件的state发生变化，React就会重新渲染，这是因为shouldUpdate默认返回的是true。因此可以通过该生命周期来决定是否要渲染组件。
   ```

7. React中什么是受控组件和非受控组件。

   ```
   受控组件:表单元素的值需要React管理。比如Input输入框，React通过监听onChange事件，然后再去更新state的值。
   非受控组件:表单元素的值由自身去管理部依赖React。可以通过ref来获取表单的值。

8. 对React context的理解。

   ```
   context是React提供一种数据共享的方式，当我们需要跨层级传递参数可以使用该方式。通过Provider注入需要传递的参数，然后在需要组件的使用Consumer接受参数即可。React提供的Context对象就是就给子组件提供了一个作用域，而Context上的属性可以看成活动对象。所以组件可以通过Context访问到父组件链上所有节点提供的Context属性。但是当如果其中的一个中间件shouldUpdate返回的是false，那么其后面的组件将不在接受context的变化而触发render。

9. 类组件与函数组件有什么异同？

   ```
   相同点：组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素
   不同点：
   1、类组件面试对象编程。函数组件是函数式编程。
   2、类组件通过shouldUpdate优化性能。函数组件通过useMemo优化性能。
   3、如果需要使用生命周期，那么使用类组件。反之则使用函数组件。

##### 数据管理

1. React setState调用原理。

   ```
   当我们调用setState更新state时，并不会立即更新state的值，而是将新的state放入更新队列中，然后判断是否是批量更新，如果是批量更新，那么将其放入等待队列中等待下一次的批量更新。如果不是批量更新，则更新state的值，并渲染视图。

2. React setState调用之后发生了什么？是同步还是异步？

   ```
   在代码中调用setState方法后，React会将传入参数与当前组将状态合并，然后进行diff算法，比较新旧树的差异，并自动记录其差异。如果在短时间内频繁setState，eact会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。
   setState同/异步是根据场景而决定的。
   异步场景：在React可以控制的地方。比如React在生命周期和合成事件中，都会走合并策略，延迟执行。
   同步场景：在 React 无法控制的地方，比如原生事件，如setTimeout等。

3. 在React组件的this.state和setState有什么区别。

   ```
   setState本质是通过一个队列机制实现state更新的。用setState时，会将修改的state放入到队列中。出于性能考虑，多次的setState调用，最后会合并成一次调用。而this.state其本质没有将修改放入队列中，所以也不触发render。
   ```

##### 生命周期

1. React的生命周期有哪些？

   ```
   React生命周期分为三个阶段。
   1、装载阶段。
   2、更新阶段。
   3、卸载阶段。
   componentWillMount:在render之前执行。
   componentDidMount:组件挂载完成后。用来获取网络数据，执行DOM操作等。
   componentWillUpdate:组件更新之前。
   componentShouldUpdate:组件是否应该更新，可以通过返回true或false，来决定是否渲染组件。
   componentDidUpdate:组件更新完成。
   componentWillUnmount:组件将要卸载。可以用来取消事件的订阅或者释放内存。
   componentDidCatch:组件发生错误时，出触发该生命周期。可以用来捕获异常信息。
   tips：现在都推荐函数组件加hooks的写法了，因此生命周期可以被忽略了。

##### 组件通信

1. 组件之间的通信方式有哪些？

   ```
   父组件向子组件通信：通过props参数传递。
   子组件向父组件通信：通过props+回调函数。
   跨级组件的通信方式：1、利用第三方组件库，如mobx。2、利用Context。3、利用自定义事件通信。
   ```

##### 路由

1. React-Router的实现原理是什么？

   ```
   同Vue-Router。

2. React-Router的路由有几种模式？

   ```
   broswerHistory、hashHistory。

3. React-Router如何获取参数？

   ```
   1、get传值。通过正则去解析url里面的参数。
   2、动态路由传值。可以通过match.参数名或hook useParam获取。
   3、query或state传值。location.state或location.query获取。但是存在缺点就是只要刷新页面，参数就会丢失。

4. React-Router在怎样在路由变化时重新渲染同一个组件。

   ```
   监听componentWillReceiveProps生命周期。

##### Hooks

1. React Hook实现原理是什么？

   ```
   当函数组件第一次渲染执行上下文是，每个reack hooks执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上，然后react hooks的状态，绑定在当前hooks对象的memoizedState属性上。对于effect副作用钩子，会绑定在workInProgress.updateQueue(保存待更新队列)上，等到commit阶段，dom构建完成，在执行每个effect副作用钩子。
   tips:hooks 主要属性
   hooks = {
   	baseState,//初始值,
   	memoizedState,//hook state信息
   	queue,//待更新队列
   	baseQueue,//最新更新队列
   	next,//链表指针
   }

2. 为什么useState要使用数组而不是对象？

   ```
   如果返回的是对象，结构时必须要和useState内部实现返回的名称同名，想要使用多次，必须设置别名。返回数组则不会有这样的问题。

3. React Hooks解决了哪些问题？

   ```
   1、能够从组件中提取状态逻辑和将组件拆分成更小的颗粒度，使得这些逻辑可以单独测试复用。
   2、类组件语法有些冗余，且需要理解this指向问题。Hooks结合函数式组件使得语法更加简洁明了。

4. useEffect 与 useLayoutEffect的区别。

   ```
   共同点：用来处理副作用。包括数据的请求，事件订阅，DOM操作等。
   不同点：
   useLayoutEffect 是在所有DOM变更之后会同步调用，主要用来操作DOM(先改变DOM后渲染)，且不会造成页面闪烁。useEffect是异步调用的，当用来操作DOM时，可能会造成屏幕闪烁(先渲染，在改变DOM)。

5. 为什么不能在条件语句中调用 Hook 呢？

   ```
   在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。

##### 虚拟DOM

1. React diff算法原理是什么？

   ```
   Diff算法通过比较新旧树的差异，将更新的补丁作用于真实的DOM。React diff 从三个策略进行复杂度的优化。
   基于树组件对比：忽略节点跨层级操作场景。对比同一层级节点，如果发现该节点不存在，那么就会直接删除该节点，而不用继续去比较其子节点。
   基于组件对比：如果组件类型一致，则默认相似结构。反之，则为不同的结构。如果组件是同一类型，就会进行对比，如果不是则放入补丁中。
   基于节点对比：同一层级的子节点，可以通过key的方式进行列表对比。元素对比发生在同层级中，通过标记节点的方式操作补丁。节点的操作包括插入、移动、删除等。而React可以标记key来追踪被修改的元素，直接对这些元素进行操作，需要遍历递归，从而比较提高效率。

2. React key 是干嘛用的？

   ```
   key的作用就是用来追踪哪些元素被修改、删除、移动等。在比较新旧树差异时，无需递归比较整棵树，只需要比较被标记元素即可，提高效率。

3. React 与Vue的diff算法有何不同？

   ```
   相同点：
   1、不做跨层级节点比较
   2、通过key提升diff效率
   不同点：
   1、Vue进行diff时，调用patch函数，一边比较一边给真实DOM打补丁。
   2、Vue点的列表对比，采用的是中间到两端，React列表对比则是从左往右依次对比。
   3、Vue对比节点是，当节点类型相同时，如果className不同，则认为是不同的元素类型，删除重新创建。而React则认为是同类型节点，进行修改操作。
   ```

##### 其他

1. React状态提升是什么？使用场景有哪些？

   ```
   多个组件需要共享的状态提升到它们最近的父组件上，然后由父组件通过属性的形式分发给各个子组件。
   ```

2. 为什么React要用JSX？

   ```
   JSX是JavaScript的语法扩展。一种类似于XML的数据结构。XML在数据结构描述更具有可读性。且JSX语法可以使用完整的JS语法来构建页面。比如可以使用临时变量、条件控制语句等。
   ```

3. React设计思路，它的理念是什么？

   ```
   1、简化可复用的组件
   2、Virtual DOM
   3、函数式编程
   ```
   
4. useState更新相同的State,函数组件执行2次？

   ```
   函数组件渲染是通过workInProgress内存树和current渲树来实现的。两棵树之间通过alternate属性关联起来的。
   当第一次渲染时，树A不存在alternate属性，所以就将树A直接复制一份当做workInProgress称为树B。所有的操作都在树B中进行，当state值更新后，以树B渲染。渲染完成后。树A和树B通过alertnate互相指向。此时树B作为下一次current树。
   第二次调用是，current树的值已经是更新后的值，而workInProgress内存树还是初始值，两棵树的baseState不一致，因此组件就会重新渲染一次。

### 计算机网络

------

##### HTTP协议

1. GET和POST的请求区别。

   ```
   是否有缓存：浏览器一般会url进行缓存。但很少会对post请求缓存。
   安全性质：get请求会将参数放在url中，这样url请求会被浏览器记录。
   请求长度：浏览器对get请求的长度有限制。
   参数形式：get请求是将参数放在url后面。post请求则是将参数放在请求的报文中。

2. HTTP请求报文和响应报文组成部分。

   ```
   请求报文：
   1、请求头。包括请求方法、url地址、协议版本等。
   2、请求行。包括Host字段、Cookie、等。
   3、请求体。post、put请求参数数据。
   响应报文：
   1、响应头。包括协议版本、请求状态码等。
   2、响应行。包括响应数据类型(content-type)、是否缓存、消息发送时间等字段。
   3、响应体。服务器返回的数据。

3. HTTP1.0和HTTP2.0的区别。

   ```
   相对于HTTP1.0，HTTP2.0有以下好处。
   1、多路复用。一次连接，多个请求并用，解决了队首阻塞的问题(HTTP1.0发送消息是串行，采用先进先出的方式。当第一个请求阻塞时，就会影响到后面的请求)。
   2、请求优先级。
   3、服务器推送。允许服务器主动向客户端发送消息。
   4、头部信息压缩。HTTP1.0每次请求都会携带大量的头部信息，这些头部信息有很多重复字段，这样就占用了网络资源。HTTP2.0采用HPACK压缩方式，将头部信息压缩后在此发送(维护一张数据表，用索引表示重读的字段，然后对齐进行压缩和编码)。
   5、二进制分帧层。HTTP1.0采用的是文本传输的方式。HTTP2.0则是采用数据分帧的方式，将数据拆分成多个数据帧发送，接收到数据拼成完整的消息。
   ```

4. HTTP请求的三次握手和四次挥手。

   ```
   三次握手
   1、客户端向服务端发起连接请求。
   2、服务端收到请求后，向客户端做出应答。
   3、客户端收到服务器端的应答后，会向服务器发送一个确认报文，服务器收到这个确认报文后，建立连接。
   四次挥手
   1、客户端发服务器端发送释放请求。
   2、服务器收到请求，做出应答，此时服务器数据可能还没有发送完成。
   3、服务器发送数据完成后，发送释放连接请求。
   4、客户端收到请求后，发送答应。若该段时间内没有服务器重新请求，那么客户端就进入关闭状态了。服务器收到答应后也进入关闭状态了。
   
   tips:为什么要进行三次握手？
   为了确认双方接收能力和发送能力是否正常。如果是两次，则有可能造成网络资源的浪费和传输数据缺失。
   
   tips：为什么要进行四次握手？
   因为TCP的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。

5. 浏览器输入一个网址后发生了什么？

   ```
   1、解析url。解析url是否正确合法。
   2、判断缓存。判断请求资源是否有缓存，如果有缓存且未失效，就直接使用。否则就发起请求。
   3、DNS解析。通过DNS协议介意url来获取对应的IP地址。详情见DNS查询过程。
   4、获取MAC地址。获取IP地址，需要通过IP地址来去本机的MAC地址，数据传输需要MAC地址和端口号。
   5、三次握手。
   6、返回数据。当页面收到请求后，会返回一个html文件作为响应内容。浏览器收到响应内容，就会开始渲染页面了。
   7、渲染页面。
   	1、解析DOM节点，生成DOM树。
   	2、解析css文件，生成CSS规则树。
   	3、将DOM树和CSS树组合成渲染树。渲染树包括DOM的位置信息和其他属性信息。
   	4、浏览器生成渲染树完后，会根据渲染树的位置信息进行布局。
   	5、布局完成后，使用浏览器的UI接口对其进行绘制。等待绘制完成后，浏览器就能显示页面了。
   8、四次挥手。

6. HTTP协议的优缺点。

   ```
   优点：
   1、支持客户端/服务器模式。
   2、简单快速。客户端想服务器请求时，只需要传递请求方式和请求地址即可。
   3、灵活。HTTP可以传输任意数据类型的数据。
   缺点：
   1、无状态。无法记住通信过程中的上下文信息。
   2、明文传输。协议中使用的是文本形式传输，这样可能就能被别人截取信息，不安全。

7. URL有哪些组成部分。

   ```
   1、协议部分。比如HTTP、HTTPS等。
   2、域名部分。紧跟协议部分后面的字符串。
   3、端口部分。
   4、路径名称。从第一个'/'到最后一个'/'之间的名称。
   5、锚部分。'#'后面的部分。
   6、参数部分。'?'之后的部分。参数之间用&连接。
   ```

8. HTTP协议的特征。

   ```
   管道化。请求按照先进先出的队列方式。
   无状态。HTTP是一种无状态的协议的。
   持久连接。通信两端如果一方没有提出断开连接，就保持连接。以便下次连接，避免造成连接和断开的开销。

##### HTTPS协议

1. HTTPS如何保证安全的？

   ```
   HTTPS通过TLS/SSL来数据进行加密。主要采用对称加密、非对称加密、数字证书这几种加密方式。
   对称加密：双方都使用同一个秘钥进行加解密。秘钥通过网络传输有可能会被别人获取。
   非对称加密：拥有两个秘钥。一个公钥、一个私钥。当我们采用私钥加密时，只有公钥才能解密。使用公钥加密时，只有私钥才能解密。在使用时只需要将公钥发布出去即可。该加密算法计算复杂，且加密速度慢。
   数字证书：对称/非对称加密。秘钥是通过网络传输，都有可能被劫持的风险。数数字证书相对于这两种加密方式更安全，但是费用高。客户端发起HTTPS请求时，服务器会返回一个公钥证书，使用公钥对数据进行加密后在发送。

##### DNS

1. DNS完整查询过程。

   ```
   1、在浏览器缓存中查询对应IP地址，找到则返回，否则进行下一步。
   2、在本地DNS服务器中查找。找到则返回，否则进行下一步。
   3、在根域名中查找。
   4、在顶级域名中查找。
   5、在权威域名中查找。
   6、如果在上述过程中，找到对应IP，会将结果保存在缓存中并返回给浏览器。找不到就报错。

##### 网络模型

1. OSI七层模型。

   ```
   1、应用层。为程序提供各种服务。
   2、会话层。建立管理维护会话。
   3、表示层。用来处理数据的操作。
   4、网络层。IP地址及路由选择。IP协议属于这一层。
   5、传输层。建立、管理端与端之间的连接。TC和UDP属于一层。
   6、数据链路层。提供访问介质。
   7、物理层。提供物理访问介质。

2. TCP/IP五层协议。

   ```
   1、应用层
   2、网络层
   3、传输层
   4、物理层
   5、数据链路层

##### TCP和UDP

1. TCP和UDP的区别。

   ```
   1、TCP面向连接。UDP则无连接，只管发送数据，不管数据是否发送成功，因此UDP连接不可靠。
   2、TCP只能支持一对一连接。UDP支持一对一、一对多、多对多连接。
   3、TCP主要用于效率相对较低，但是准确性较高的场景。如文件传输，数据更新等。UDP主要用效率较高，准确性较低的场景。如即时通话等。
   tips：因为TCP要进行三次握手和四次挥手，因此TCP效率要比UDP低。

##### Websocket

1. 对websocket的理解。

   ```
   websocket 是HTML5提供的一种浏览器与服务器全双工(双向同时)通信方式，属于应用层协议。它基于TCP传输协议，浏览器与服务器只需要一次握手，就能建立持久性连接，并进行双方数据通信。其特点是客户端能够向服务器推送消息，服务端也能向客户端推送消息。主要有以下几个事件和方法。
   1、onmessage。监听收到数据触发事件。
   2、onclse。关闭连接触发事件。
   3、send。发送消息方法。
   4、onopen。打开连接触发事件。
   ```
   
2. 短轮询、长轮询以及websocket的区别。

   ```
   短轮询：浏览器每隔一段时间就想服务器发送一次消息，服务器收到消息后，无论是否数据有更新，都会做出响应。这样会造成服务器压力大。
   长轮询：客户端向服务端发起请求，建立请求后，服务器不会立即响应这个请求，而是会将这个请求挂起，不会断开请求，等到有数据更新或者达到一定时间后，服务器才会做出响应。当客户端收到响应时，处理完数据后，会重新发次请求。挂起过程，也会造成资源的浪费。
   websocket：全双工通信，支持服务端与客户端双向通信。缺点就是服务器端配置较复杂。

### 浏览器原理

------

##### 浏览器安全

1. XSS和CRSF是什么？怎样防御。

   ```
   XSS是一种跨站脚本攻击，是一种脚本注入工。通过在网站上，注入脚本，从而盗取用户cookie等信息。其本质就是网站是没有对恶意的代码进行过滤，导致恶意代码与正常代码一起运行。
   XSS防御：
   1、使用纯前端的方式，不使用服务端拼接返回内容的方式。
   2、通过对恶意代码进行过滤，即对插入HTML的代码进行充分的转义和过滤。
   CRSF是一种跨域请求伪造攻击。本质上就是利用cookie在同源请求会携带并发送给服务器的特点，利用这一点就可以实现跨域请求伪造攻击。可以通过以下方式来防止该攻击。
   1、cookie同源。通过判断HTTP请求中的refer或origin的信息来判断是否允许访问。
   2、利用token验证。服务器会向用户返回一个token令牌，每次发起请求，都会携带这个token，然后服务器对这个token进行验证是否正确。
   3、在设置cookie时设置same site，限制cookie被第三方使用。

##### 进程和线程

1. 进程和线程的区别。

   ```
   进程：资源分配的最小单位。启动一个程序时，操作系统就会为该程序创建一块内存，用来存放代码、运行中的数据和一个运行任务执行的主线程等，我们称这样的运行环境为进程。
   线程：CPU调度的最小单位。
   进程与线程有以下的特点：
   1、进程中任意一线程出错，会导致程序报错
   2、进程之间的内容互不干扰
   3、当进程关闭时，操作系统会回收进程所占用的内存
   4、线程之间数据共享
   ```

2. 谷歌浏览器常用浏览器进程有哪些？

   ```
   1、浏览器主进程。主要用来显示页面、用户交互等功能。
   2、GPU进程。浏览器UI界面绘制。
   3、渲染进程。将HTML、Css、JavaScript转化成与用户交互的网页。
   4、网络进程。主要负责页面网络资源的加载。
   5、插件进程。主要是负责插件的运行。

##### 浏览器缓存

1. 对浏览器的缓存机制的理解。

   ```
   首先判断是否命中强制缓存，没有命中就进行协议缓存。如果两种缓存都没有命中，那么就是启发式缓存。
   强制缓存
   	1、如果cache-control：no-cache，那么就是无强制缓存，直接进入协议缓存阶段。
   	2、如果cache-control：max-age=xxx,就会比较当前时间与上一次请求成功的时间差，是否小于max-gae，如果小于max-age，就读取缓存内容。
   	3、强制缓存会触发from disk cache(样式、脚本、图片等) 硬盘缓存和from memory cache(大文件等) 内存缓存，优先会从内存中读取缓存，然后再是硬盘缓存。
   协议缓存:协议缓存中有两个重要的属性，一个是If-Modifed-Since，另外一个是If-None-Match。If-Modifed-Since比较的是服务器时间，而If-None-Match比较的是ETag(服务器会为每个资源文件生成一个唯一的标志)。如果命中缓存则返回304。不一致则返回新的Last-Modified时间或文件并返回200。
   启发式缓存:如果没有设置任何缓存策略，就会启用该缓存，通常会根据响应头中的两个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。

2. 浏览器资源缓存的位置有哪些。

   ```
   Service Worker：离线缓存。
   Memory Cache：内存缓存，它的效率最快。读取高效，缓存时间短。一旦关闭tab页签，缓存就被释放了。
   Disk Cache：储在硬盘中的缓存，读取速度慢点。读取效率低，但是缓存时间长。

##### 浏览器渲原理

1. 浏览器渲染过程

   ```
   1、解析DOM节点，生成DOM树。
   2、解析css文件，生成CSS规则树。
   3、将DOM树和CSS树组合成渲染树。渲染树包括DOM的位置信息和其他属性信息。
   4、浏览器生成渲染树完后，会根据渲染树的位置信息进行布局。
   5、布局完成后，使用浏览器的UI接口对其进行绘制。等待绘制完成后，浏览器就能显示页面了。
   ```

2. 渲染过程中遇到JS文件如何处理。

   ```
   JavaScript的加载、解析、执行会阻塞文档的解析。在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。因此应该将JS文件放在body后面，等待DOM解析完成，再去解析和执行JS文件。
   ```

##### 浏览器同源策略

1. 是什么同源策略。

   ```
   同源策略就是协议、域名、端口一致。同源策略目的是主要为了保护用户信息安全。跨域请求就是同源策略引起的。它只是一种对js脚本的限制，并不是对浏览器。对于一般的img或者脚本不会有限制。

2. 如何解决跨域问题。

   ```
   1、CROS。通过服务器端设置Allow-Origin、Allow-Methods、Allow-Headers来实现跨域请求。
   2、JSOP。利用<script>标签没有跨域限制，通过src属性发送带callback请求来实现跨域。
   3、postMessage跨域。通过iframe的postMessage方法以及监听message事件来实现跨域。
   4、nginx代理跨域。实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段来实现跨域。

##### 浏览器本地存储

1. cookie、localStorage、sessionStorage的区别。

   ```
   cookie：cookie数据始终在同源的http请求中携带（即使不需要），可以设置过期时间和在哪个路径下cookie生效，大小为4k。在cookie有效期间，关闭浏览器和窗口，cookie不会被销毁。
   localStorage：请求不会在同源http中携带。大小为5M或更多。localStorage存储在本地硬盘中，因此用作持久数据。在所有同源窗口中数据共享。
   sessionStorage：和sessionStorage类似。但是当浏览器关闭和窗口关闭时。sessionStorage会自动销毁。不在不同的浏览器窗口中共享，即使是同一个页面。

##### 浏览器事件机制

1. JavaScript事件模型？

   ```
   事件捕获和事件冒泡。
   事件捕获：从document往下一直到达目标元素。
   事件冒泡：从目标元素往上一直到达document。
   ```

2. 对事件循序的理解。

   ```
   1、JS的单线程任务被分成同步任务和异步任务。同步任务在主线程中执行，而异步任务在被加入到一个队列中。
   2、当同步任务执行完成后，就开始读取异步任务，并推入主线程开始执行。而异步任务又分为宏任务和微任务
   3、当开始执行异步任务时，首先从宏任务开始执行，当队列里面宏任务执行完成后，就开始执行微任务，并将所有微任务执行完成。开始读取下一个宏任务。
   4、不停重复宏任务与微任务的执行过程，直到所有任务执行完成。
   tips：
   宏任务：setTimeout等。
   微任务：Promise、MutationObserve等。
   ```

3. Node中 Event Loop和浏览器有什么区别？

   ```
   ---

### 前端工程化

------

1. 开发一个脚手架的流程。

   ```
   脚手架主要作用是通过将远端的初始化项目模板拉取至本地中，可以用过参数配置来定项目所需功能，主要分为以下几个步骤。
   1、新建一个bin目录，然后创建对应的命令文件。
   2、引用commander第三方库，自定义命令。
   3、在pagejson文件，新增bin属性，在bin属性下面新增，自定义命令，需要与commander定义的命令保持一致，这是命令的入口地址。
   4、完成每个命令完成对应的功能即可。
   5、可以使用npm link在命令全局挂载来测试功能是否正常。
   
   采用的第三方库
   1、inquiry。交互式命令行工具。
   2、commander 用来编写指令和处理命令行。
   3、download-git-repo 用来下载远程模板的，支持 GitHub、 GitLab 和 Bitbucket等。

2. 常见的Loader和Plugin。

   ```
   Loader
   1、file-loader。处理图片和字体资源文件。
   2、ts-loader。ts转化成js。
   3、babel-loader。将ES6转化成ES5，以及转化JSX。
   4、css-loader。加载css，支持压缩、模块化等功能。
   5、sass-loader。将sass样式转化成css样式。
   6、vue-loader。将vue转化成js。
   Plugin
   1、define-plugin。用来定义环境变量。
   2、html-webpack-plugin。创建HTML文件以及其依赖。
   3、mini-css-extract-plugin。分离样式文件。支持css文件提取。
   4、clean-webpack-plugin。清除目录文件。

3. Loader和Plugin的区别。

   ```
   Loader本质上是一个函数，用来转化Webpack无法识别的文件类型，因为webpack只能识别js。通过在module.rules中配置，类型为数组。
   Plugin是webpack插件。在webpack运行过程中会广播出许多生命周期，plugin则是通过监听这些生命周期来实现对打包结果的改变。在Plugin中配置，每一项都是一个plugin实例，参数通过构造函数传入。

4. Webpack构建流程。

   ```
   分为三个步骤。
   初始化：启动构建，合并配置参数。加载Plugin，实例化complier。
   编译：从入口Entry出发，对于不同的文件内容调用不同的loader去处理，递归遍历各文件之间的依赖关系。
   文件输出：将编译后的文件组合成chunk，将chunk转化成文件并生输出到文件系统中。

5. 文件监听原理。

   ```
   在文件源码发生变化时，自动构建。可以通过命令--watch或者配置watch：true开启该功能。这是通过轮询判断文件的最后编辑时间是否发生改变，如果某个文件发生变化，并不会立即告诉监听者，而是将其缓存起来，等到合适的时间才会去执行。这种文件监听不会触发浏览器自动刷新，每次构建完成都需要收到刷新浏览器才能看到构建后的内容。

6. webpack热更新原理。

   ```
   HMR的核心就是客户端从服务端获取更新后的差异文件，WDS与浏览器维护了Websocket连接，webpack通过watch方法来实现对文件监听。当源文件发生变化时，会自动构建项目，等项目构建完成后会向客户端推送编译后hash，客户端收到消息，对比上一次的hash值是否发生变化，如果发生变化，那么客户端会通过ajax和jsonp来获取这些差异信息并自动刷新当前，这样就能实时看到更新后的页面。如果hash未发生变化，则走缓存。
   
   热更新几个模块tips：
   1、Bundle Server。提供网页访问服务
   2、HMR Sever。将热更新的文件输送给HMR runtime。(知道哪些资源文件发生了变化)
   3、HRM runtime。在构建阶段，会被注入到bundle.js里面。(接受差异文件，并更新代码)
   4、bundle.js。构建最终输出文件。
   hot-update.json是用来通知HRM runtime哪些文件发生了变化的数据对象。

7. 文件指纹是什么？

   ```
   文件指纹是打包后输出的文件名的后缀。
   Hash：整个项目文件有关。只要有项目文件发生变化，该值就会发生变化。
   ContentHash：根据文件内容来决定该值是否发生变化。
   ChunkHash：Chunk发生变化时，该值发生变化。

8. 如何优化Webpack 的构建速度？

   ```
   1、开启缓存提升二次构建速度。
   2、资源文件压缩。
   3、多线程压缩。
   4、动态分离库。
   5、提取页面公共资源。
   6、摇树优化。
   7、定向搜索。
   8、按需加载，动态polyfill。

9. 如何编写Loader。

   ```
   Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。
   1、Loader运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用。
   2、Loader 是无状态的，我们不应该在 Loader 中保留状态。
   3、使用 loader-utils 和 schema-utils 为我们提供的实用工具。
   4、尽可能的异步化 Loader，如果计算量很小，同步也可以

10. 如何编写Plugin。

    ```
    webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。
    1、compiler是与Webpack整个生命周期相关的钩子。
    2、compilation是每次构建过程中的生命对象，是通过compiler实例化得到的。
    3、创建一个插件类，可以通过构造函数来获取外面传递给插件的参数。
    4、插件需要在原型上绑定apply方法，才能访问compiler实例。
    5、找出合适的事件点完成功能。
    6、异步事件调用完成需要调用回调函数(callback)通知webpack进入下一个流程

11. Babel的原理。

    ```
    分为三个阶段。
    1、解析。
    	词法拆分：将代码拆分为tokens。
    	语法解析：检查tokens是否具有语法错误，如无错误将其转化成AST。
    2、转化。访问AST节点并生成新的AST。其中的操作包括节点的移动、删除、复制等。
    3、生成。将转化的AST生成代码字符串。

12. @babel/runtime和@babel/polyfill的区别。

    ```
    这两个库的作用都是将ES6转化成ES5代码。
    @babel/polyfill
    1、体积太大。无法做到按需加载。
    2、容易污染全局环境。polyfill是通过设置全局对象和内置对象的原型来实现的。如果第三方库也引入了polyfill，并且改写了内对象的原型上的方法，就会导致功能失效。
    @babel/runtime 是为编译语法提供的运行环境。它是一个模块且不会污染全局变量和内置对象，需要配合@babel/plugin-transform-runtime一起使用，@babel/plugin-transform-runtime作用是转化代码是提供辅助函数和避免多次编译出helper函数。但是如果是实例上的方法是无法访问的。
    
    tips：
    @babel/cli。编译命令用来编译文件或文件夹。
    @babel/preset。编译的目标环境。(如es6、es5等)
    @babel/polyfill。提供编译器需要的语法环境。babel7已经弃用，采用core-js替代。
    @babel/runtime。提供编译器需要的语法环境。一种替代polyfill的方案。需要配合@babel/plugin-transform-runtime一起使用。
    @babel/plugin-transform-runtime。提供转化代码的辅助函数和避免多次编译出helper函数。
    ```

13. npm与yarn的区别。

    ```
    相比npm，yarn有以下优势。
    1、速度快。
    	npm是串行安装，而yarn则是并行安装。
    	之前已经安装过的包，yarn是从缓存中获取。
    2、安装依赖统一。每次执行安装命令时，会默认自动生成一个yarn.lock文件用来锁定依赖版本。
    3、更简洁的输出。npm 的输出信息比较冗长。
    4、更好的语义化。yarn命令更加简单明了。

### TypeScript

------

### 其他

------

1. cookie、session、sessionStorage、localStorage的区别。

   ```
   cookie：cookie数据始终在同源的http请求中携带（即使不需要），可以设置过期时间和在哪个路径下cookie生效，大小为4k。在cookie有效期间，关闭浏览器和窗口，cookie不会被销毁。
   session:session是存储在服务器端。相对于cookie更安全，存储数据类型和数据大小也比cookie更加有利，但是当客户端关闭的时候，session会失效。
   localStorage：请求不会在同源http中携带。大小为5M或更多。localStorage存储在本地硬盘中，因此用作持久数据。在所有同源窗口中数据共享。
   sessionStorage：和sessionStorage类似。但是当浏览器关闭和窗口关闭时。sessionStorage会自动销毁。不在不同的浏览器窗口中共享，即使是同一个页面。

2. 前端的几种鉴权方式。

   ```
   Session：用户登录后，服务端会返回一个sessionID，客户端会将sessionID存到cookie中，等到客户端第二次请求，会携带cookie信息(包括sessionID)，服务器接收到sessionID后，会查找对应的session信息。如果能找到，说明校验通过可以进行后续操作。如果校验不通过，说明sessionID已经失效，需要用户重新登录。由于session是存储在服务端，所以当用户过多时，会对服务端造成压力。且session无法在多个服务器之间共享，所以无法进行分布式部署。由于sessionID是存储在cookie中，如果浏览器被禁止使用cookie，可以加sessionID以参数的形式放在url中。
   
   Token：用户登录后，服务端会返回一个token令牌，客户端会将其保存起来了，然后每次请求通过将token放在请求头Header里面发送给服务端。服务端接受到token后会根据token信息去数据库中查询用户信息进行验证。如果验证通过，就可以进行下一步操作，反之校验失败。通过这种方式服务端不用存储token，从而减轻服务端压力。
   Refresh Token：主要作用是刷新token。当token过期时，会检验Refresh Token 是否过期，如果Refresh Token未过期，那么就会重新生成一个token返回，反之，就需要用户重新登录以此来获得新的token了。使用数据库内存储token会导致查询时间过长，因此可以将其放入到redis内存中。
   
   JWT：即JSON Web Token，是一种token的编码方式。通过添加请求头Header中的Authorization属性Bearer来添加JWT。JWT通常由三部分组成header，payload，sign三部分组成。header是用来指定签名的算法，payload就是要加密的信息，sign就是密钥跟算法生成的签名。使用JWT是以将加密后的数据存储在客户端，服务端只需要对加密后的数据进行解密即可(不需要查询数据库)。因为JWT包含了用户的认证信息，因此需要将JWT的有效期设置较短和采用HTTPS加密传输。
   
   SSO：即单点登录。不同的项目，一次登录，全线通用。
   1、主域名相同子域名不同。比如(wenku.baidu.com,tieba.baidu.com)。可以将cookie.domain设置为主域名即可(即共享cookie来判断用户是否登录)。
   2、主域名不同。
   用户进入A系统，没有登录凭证，A系统就会跳到SSO，在SSO登录成功后，通过接口会做两件事，在SSO种下凭证信息(即在SSO域名写入cookie)和返回ticket(token用来做接口认证的)。客户端拿到ticket，保存起来，带着ticket发起请求。如果ticket校验通过，就可以进行后续的操作。
   用户进入B系统，没有登录登录凭证，此时会跳转到SSO，SSO登录过(即之前A系统登录是写入的cookie信息)，系统下有凭证信息，不用再次登录。直接下发ticket，客户端拿ticket，保存起来，发起请求时携带ticket就能完成校验了。
   上述的方法在浏览器中，如果SSO返回的数据系统A请求时是无法通过cookie、localStorage等方式携带的。可以通过JWT的方式实现跨域认证。

