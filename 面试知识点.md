[TOC]

### HTML

------

##### 1、src和href有什么区别？

```javascript
src：表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本，浏览器遇到src会暂停其他资源下载，等到该资源下载完成，在进行其他资源的下载，会阻塞DOM的解析。
href：表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。不会阻塞DOM的解析。
```

##### 2、script标签中defer和async的区别？

```javascript
defer和async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析。
defer：按照顺序执行脚本文件，不会阻碍HTML的解析。
async：不能保证加载的顺序，脚本下载成功够立即执行，有可能会阻碍HTML的解析。
```

##### 3、Canvas和SVG的区别。

```javascript
SVG:SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言。它不依赖分辨率，支持事件处理器适合大型渲染区域。
Canvas:Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。它依赖分辨率，不支持事件处理器，能够以.png 或.jpg 格式保存结果图像。
```

##### 4、渐进增强和优雅降级之间的区别。

```javascript
渐进增强:主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。
优雅降级:一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。
```

##### 5、对盒模型的理解。

```javascript
盒模型分为标准盒模型和IE盒模型。其中盒模型组成部分都是content、border、padding、margin四部分组成。可以通过box-sizing(content-box:标准盒模型(默认值)。border-box:IE盒模型)属性来改变盒模型。
标准盒模型：元素的width和height只包含了content。
IE盒模型：元素的width和height包含了padding、border、margin。
```

##### 6、documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？

```javascript
当我们把一个DocumentFragment节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。
```

##### 7、对语义化的理解。

```JavaScript
语义化就是根据内容结构化，选择合适的标签。这样做的好处
1、对机器友好，适合搜素引擎的爬虫爬取有效信息，利于SEO。
2、对开发者友好，增加可读性，结构更加清晰，便于团队的开发与维护。

常见的语义化标签有
header 头部
nav 导航栏
section 定义文档中的节
main 主要区域
article 定义文章内容
aside 侧边栏
footer 底部
```

### CSS

------

##### 1、CSS选择优先级。

```javascript
以下优先级依次递减。
1、ID 选择器（例如，#example）。
2、类选择器（例如，.example），属性选择器（例如，[type="radio"]）和伪类（例如，:hover）
3、类型选择器（例如，h1）和伪元素（例如，::before）。

css选择特定性计算(0,0,0)。
第一个数字表示ID选择器数量。
第二个数字表示类选择器数量。
第三个数字表示类型选择器数量。
```

##### 2、display的block、inline和inline-block的区别。

```javascript
block:会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；
inline:元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；
inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。
```

##### 3、link和@import的区别。

```javascript
1、link在页面载入时同时加载。@import等到页面加载完成才加载。
2、link支持JavaScript改变样式，@import则不行。
3、link是XHTML标签，无兼容问题，@import低版本浏览器不兼容，存在兼容性问题。
```

##### 4、对BFC的理解，如何创建BFC。

```javascript
BFC成为块级格式上下文。BFC可以理解为是一个容器，它里面的内容不会影响到其他环境的内容。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受到外界的影响。
触发BFC的条件：元素设置为浮动(float)、绝对定位、display等。其作用是解决高度塌陷的问题和margin的重叠问题、创建自适应两栏布局。
```

##### 5、什么是重排(回流)和重绘？

```javascript
重排:当渲染树中的元素结构、属性尺寸发生变化时，浏览器会重新渲染的过程叫做重排。比如：浏览器的窗口大小发生变化、元素内容、位置、字体大小发送变化等都会触发重排。
重绘:当渲染树中的元素某些样式发生变化时，但是其位置没有发生变化，浏览器就会对其重新绘制，这个过程成为重绘。比如：color、background相关属性发生变化会触发重绘。
tips：重排一定会引起重绘，但是重绘不一定会引起重排。
```

##### 6、如何避免回流与重绘？

```javascript
1、操作DOM时，尽量在低层级的DOM节点进行操作。
2、使用CSS的表达式。
3、将多个DOM操作放在一起，一次性渲染。
4、不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
5、避免频繁操作DOM，可以使用documentFragment，在它上面应用所有DOM操作，最后把他添加到文档中。
6、使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。

浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列。浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。
```

##### 7、less和scss的区别？

```javascript
相同点
Sass和Less都属于CSS预处理器,其基本思想是，用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用。
不同点
1、编译环境不一样 Less是基于JavaScript，是在客户端处理的。Sass是基于Ruby的，是在服务器端处理的。
2、变量符不一样，Less是@，而Scss是$。
3、Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。
4、文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为同名css文件。Less则不会。
```

8、CSS的属性继承和层叠。

```javascript
inherit:设置该属性会使子元素属性和父元素相同。实际上，就是“开启继承”。
initial:将应用于选定元素的属性值设置为该属性的初始值。
unset:将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样。
all: 将除了 unicode-bidi 与 direction 之外的所有属性重设至其初始值，或继承值。

层叠来源类型：用户代理样式表、用户样式表和作者样式表。
“用户代理”指的是浏览器。“用户”指的是是网站访问者。“作者”指的是你，开发者。用 <style> 元素直接在元素上声明的样式是作者样式。不包括动画和过渡样式，用户代理普通样式具有最低优先权；用户代理重要样式具有最高优先权。
```

### JavaScript

------

#### 数据类型

##### 1、JavaScript有哪些数据类型，它们的区别？

```javascript
原始类型：String、Number、Boolean、Null、Undefined、Symbol、BigInt。
对象类型：Object。
这些数据类型可分为原始数据类型和对象类型。原始类型存储在栈(stack)中，而对象类型则存储在堆中。
栈：存放的是基本数据类型的值。数据结构为采用先进后出的队列。栈区内存由编译器自动释放。
堆：存放的是对象类型在栈中的引用地址。数据结构为采用先进先出的队列。堆区内存一般由开发者手动释放，如果开发者未释放，就由程序GC机制回收。
```

##### 2、数据类型的检测方式有哪些？

```javascript
typeof：检查数据的类型。
instanceof：检查该对象是否在原型链上。
constructor: 对象实例通过 constrcutor 对象访问它的构造函数。// (2).constructor === Number true
Object.prototype.toString.call()：使用Object原型上的toString方法来检测基本类型。
```

##### 3、isNaN和Number.isNaN函数的区别？

```javascript
两个方法都是用来判断是否不为Number类型。如果不是Number类型，返回true，反之则为false。
isNaN：该方法对传入的参数会将其转化成Number类型，然后再去判断。
Number.isNaN：该方法会对传入的参数判断是否为Number类型，不会进行数据的转化。然后再去判断。相比于isNaN判断更准确一点。
```

##### 4、为什么0.1 + 0.2 != 0.3，如何让其相等？

```javascript
计算机是通过二进制的方式存储值。 0.1 + 0.2 的和其实就是计算两个二进制数据之间的和。所以就造成了偏差。可以借助Number.EPSILON对象，该对象是设置一个误差范围，表示在该误差范围内是有效的。
```

##### 5、装箱和拆箱的区别？

```javascript
1、将基本类型转化成对象类型称之为装箱。装箱会产生一个临时对象，对性能会有影响。
2、将对象类型转化为基本类型称为拆箱。在拆箱过程中会默认执行ToPrimitive方法，具体转化规则如题6。
```

##### 6、JavaScript 中如何进行隐式类型转换？

```javascript
调用一个叫ToPrimitive(obj,type)的方法。首先判断数据类型是否为基本数据类型，如果是基本数据类型，则直接返回。如果不是，则根据该方法的type类型来返回。
1、如果type为Number类型。首先调用valueOf方法，判断是否原始类型的值返回，如果有则返回。如果没有就调用toString方法，判断是否有值，有则返回，没有则抛出TypeError的异常。
2、如果type为String类型。首先调用的是toString方法。逻辑同上。
```

##### 7、Object.is() 与其他比较操作符 “==” 和 "===" 的区别？

```javascript
==：简单比较数据值是否相等。
===：比较数据值是否相等的同时比较数据类型是否相等。
Object.is()：和"==="判断类似。只不过判断+0与-0不相等。isNaN与isNaN是相等的。
```

#### JavaScript基础

##### 1、new 操作符的实现原理。

```javascript
1、创建一个新对象。
2、将新对象的_proto_属性设置为函数的原型对象。
3、将构造函数的this指向该对象。并执行函数。
4、判断函数返回值。如果函数返回的是引用类型，那么返回该对象。如果不是，那么就会创建的对象。

function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
```

##### 2、Map和Object、weakMap的区别？

```javascript
Map和Object都是采用键值对的方式存储数据。
Map：属性可以是任意数据类型。读取属性的值，能够有序的属性的值。在频繁的删除或插入键值，Map是有做过性能优化。
Object：属性只能是string、number和symbol类型。读取属性的值，是无序的，无法保证顺序。
WeakMap:作用和Map差不多。但是WeakMap的键值只能是对象，且对对象是一种弱引用。当对象的其他引用被清除掉，WeakMap里面的键名和对应的对象会自动被删除，无需手动释放。
```

##### 3、对类数组对象的理解，如何转化成数组？

```javascript
一个拥有length属性和若干索引属性的对象称为类数组。类数组不能调用数组的方法。可以用过Array.From()方法将其转化为数组。
```

##### 4、espace、encodeURI、encodeURIComponent区别？

```javascript
espace:会对传入的参数进行编码。如果只是字符串编码采用该方法。
encodeURI和encodeURIComponent都是一种编码方式。只是encodeURIComponent编码范围比encodeURI更大。如果需要对整个URL编码，且需要使用该URL，那么就用encodeURI。如果需要对URL传参编码，那么就使用encodeURIComponent。
```

##### 5、对于Ajax的理解，实现一个Ajax请求。

```javascript
1、创建一个XMLHttpRequest对象xml。
2、调用xml.open()方法。该方法提供请求类型以及请求地址。
3、调用xml.send()方法。如果是post请求，send方法里面可以传递参数。
4、监听onreadystatechange事件。当状态state为4且http状态码为200，表示请求已经完成且成功。然后可以进行其他逻辑性处理。

const SERVER_URL = "/server";
let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open("GET", url, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);
```

##### 6、对原型、原型链的理解。

```javascript
原型：JavaScript中的构造函数都会有一个prototype属性，该属性值就是构造函数的原型对象。该对象包含了构造函数所有共享的属性和方法。当通过构造函数创建实例时，实例中会有一个_proto_属性指向构造函数的原型对象。那么这个指针就成为原型。
原型链：当我们访问对象上的某个属性时，会首先从其构造函数自身的属性上去查询是否有该属性，如果不存在，就去构造函数的原型对象上查找。而构造函数的原型对象可能继承了其他函数，这样一层一层的往上查找。如果查到就返回，否则就返回undefined。这样查找的过程称为原型链。

function Parent() {}
const parent = new Parent();
console.log(parent.__proto__ === Parent.prototype); // true
console.log(Parent.prototype.constructor === Parent); // true
```

##### 7、对闭包的理解。

```javascript
闭包是在作用域外部能够访问作用域内部的变量，或者说，可以在函数外部访问函数内部的变量。
闭包的主要作用有两个。一个就是可以访问函数内部的变量的值。另外一个就是可以将函数变量的值保存在内存中，不会自动释放。因为当前函数中还存在对闭包函数的引用，即函数执行上下文还存在活动对象，并没有从执行栈中弹出，所以不会立即释放。但是过多使用闭包且不及时释放，有可能会导致内存泄漏。
```

##### 8、对作用域、作用域链的理解。

```javascript
作用域分为全局作用域和函数作用域。
全局作用域：最外层的作用域。所有未定义直接赋值的变量自动声明为全局作用域。
函数作用域：作用域是分层的，内层作用域可以访问外层作用域，反之不行。
作用域链：在当前作用域中访问变量时，会从函数内部查找，查不到就往父级作用域中查找。直至到window对象。这样查找的过程就是作用域链。作用域链保证了执行环境对函数的权限访问和变量的有序访问。
```

##### 9、对执行上下文的理解。

```javascript
分为全局执行上下文、函数执行上下文、eval执行上下文。每个上下文都包含了活动对象、作用域链、以及this对象。且执行上下文都包含了活动对象，作用域链(scope)，this这三个属性。
当函数代码被执行的时候，会创建一个全局执行上下文，并将全局上下文放到执行栈中。当遇到函数调用时，就会创建函数执行上下文，并将当前函数放到执行栈的顶部。当该函数执行完成后，就会从执行栈中弹出。直到所有代码都执行完毕，最后才将全局执行上下文中弹出。

tips：什么是执行栈？
可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，当执行完毕后就从栈中弹出了。当使用递归时，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。
```

##### 10、对this对象的理解。

```javascript
this是执行上下文中的一个属性。this指向分为以下几种情况。
1、非严格模式默认指向是window。严格模式下是 undefined。
2、调用new关键字调用时，this指向创建的实例。
3、调用apply、call、bind等方法时，this指向传入的参数对象。
4、调用对象属性里面的方法时，this指向该对象。
```

##### 11、实现call、apply、bind函数。

```javascript
实现call函数。
1、判断参数是否为函数，如果不是函数就抛出异常
2、判断是否有上下文对象，如果没有则设置为window
3、获取传入参数
4、将函数作为上下文对象的一个属性
5、执行该上下文对象属性，并保存返回结果
6、删除该属性
7、返回结果
apply和call实现原理差不多，只是传参不一样。bind函数只需要返回一个新的函数即可。
// call函数实现
Function.prototype.Call = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }
  // 获取参数
  let args = [...arguments].slice(1),
      result = null;
  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;
  // 将调用函数设为对象的方法
  context.fn = this;
  // 调用函数
  result = context.fn(...args);
  // 将属性删除
  delete context.fn;
  return result;
};
```

##### 12、浏览器垃圾回收机制。

```javascript
当JavaScript运行中，需要分配内存空间来存储变量和值。当变量不在参与运算后，就会被回收，以达到释放内存的目的。这就是垃圾回收。
浏览器垃圾回收机制主要使用两种方式。
1、清除标记。当变量进入执行环境时，就会打上一个标记(进入环境),表示当前变量正在使用，无法清除。当变量离开执行环境时，就会被标记为(离开环境)，离开环境的标记就自动被清除，并被内存释放。
2、引用计数。跟踪记录每个值被引用的次数。当一个变量被赋值另外一个引用类型变量时，该值引用计数就会加1。相反，当该变量的值发生改变时，该值的引用计数就会减1。当该值引用计数变为0时，该值就会从内存中释放。
```

##### 13、解释性语言和编译性语言的区别。

```javascript
解释性语言：无法在机器上直接运行，需要由解释器将代码编译成机器码之后在执行。常见的解释性语言有JavaScript、Python等。每次执行代码都需要编译一次，执行效率相比于编译性语言要低一些。编译后直接在该平台运行，运行速度快。
编译性语言：需要由编译器编译后，能在机器上直接运行。编译后的代码会生成一个可执行文件。如.exe等。 以后要执行代码时，直接执行编译后的文件即可，无需每次编译。运行期间才编译，跨平台性好。
```

##### 14、JavaScript执行过程是怎样的？

```javascript
执行过程可分为三个过程。
1、词法拆分：将js代码拆分为字节流(token)，加入到一个AST数组中
2、语法分析：分析AST数组，检查是否有语法错误。如果有错误，就抛出语法异常，没有就执行下一步
3、代码生成：将AST转化成机器可执行的机器码，并执行代码
```

##### 15、前端模块化的理解。

```javascript
AMD：requireJS是基于该规范实现。依赖前置(提前加载)。依赖的函数会立即下载并运行，相对于seaJS用户体验更好。
CMD：seaJS是基于该规范实现。就近依赖(按需加载)。依赖函数会下载，但不会立即执行，等到需要它的时候才会运行。相对于requireJS性能更好。
CommonJS：node是基于该规范实现。是一个同步的加载模块。
ESM：ES6模块语法。提供export和import导出和导入模块。
UMD：将上述几种模块综合起来，支持各种模块。
```

##### 16、ESM模块和CommonJS模块的区别。

```javascript
1、CommonJS是require运行时加载(同步)。ESM import则是异步加载，可以用来做静态分析。
2、CommonJS通过module.exports 的值不会发生改变(导出的是值的拷贝，导出的是一个对象)。ESM通过export导出的值是会发生改变的(导出的值是引用类型，导出的不是对象，而是对外接口只是一种静态定义，在代码静态解析阶段就会生成)。
3、CommonJS可以写在语法里面。ESM是静态语法只能写在最顶层。
4、CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined
5、CommonJs 是单个值导出，ES6 Module 可以导出多个

tips:module.exports 指向的是一个模块对象，而exports是module.exports 的一个引用对象。
module.exports = {/*导出内容*/}
exports = module.exports;
return module.exports
```

##### 17、为什么函数的arguments参数是类数组而不是数组？

```javascript
函数的arguments是一个对象，它的属性是从0开始依次递增的，有callee和length等属性，与数组相似；但是没有数组常见的属性。不能直接遍历。
```

##### 18、requestAnimationFrame和**requestIdleCallback**的理解。

```javascript
requestAnimationFrame是浏览器用于定时循环的一个接口。主要用于网页按帧重制。相比于setTimeout它具有以下有点。
1、它会把每一帧中所有的DOM操作集中起来，在一次重绘或重排中完成。并且重绘或重排的时间紧跟浏览器的刷新频率。
2、当页面未被激活时，页面的刷新机制也会被停止。当页面激活时，页面刷新机制会从上次暂停的地址继续开始。
缺点：兼容性不好

requestIdleCallback会在浏览器空闲时执行的回调，在主事件循环中执行低优先级任务，而不影响一些延迟关键事件。如果有多个回调，会按照先进先出原则执行。
```

##### 19、常见的函数式编程方法。

```javascript
纯函数：相同的输入永远得到相同的输出，过程没有副作用，不依赖外部状态。比如React中的高阶组件就是一个纯函数。
柯里化：将多元函数拆成一元函数。
函数组合式：将上一个函数执行的结果当做参数传递给下一个函数，由多个函数组合而成，这样当某个函数报错时，能更快的定位到错误信息。比如Webpack中loader的加载顺序就是通过这样的方式加载的。
```

##### 20、use strict是什么意思 ? 使用它区别是什么？

```javascript
use strict 是一种 ECMAscript5 添加的（严格模式）运行模式。
区别：
1、禁止使用 with 语句。
2、禁止this关键字指向全局变量。
3、对象不能有重名的属性
```

##### 21、为什么要求通过void 0代替undefined？

```javascript
undefined 表示类型未定义，任何变量未赋值前都是undefined。在JavaScript中，undefined是一个变量，而不是关键字，因此undefined可以赋值给其他变量，从而导致获取undefined失败，因此可以用void 0来获取正确的undefined。
```

##### 22、为什么12.toString会报错？

```javascript
在JavaScript中，"." 运算符存在歧义，它既可以当属性访问符，也可以是小数点，这取决于它在代码中的位置。规范中定义了 "." 运算符仅在特定的位置使用时会被当作小数点,所以，当你想要在数字后加属性访问器的点号时，应当加上括号，或再加上一个点，以使该表达式合法。
```

##### 23、for和forEach的区别。

```javascript
本质区别：for其实一种循环机制，能通过它遍历数组。forEach则是一个迭代器。遍历可迭代的对象(Array,Set,Map)等。
语法区别：for可以控制循环的起点、可以通过break、continue中断遍历。forEach索引只能从0开始，可以通过try、catch中断循环。
性能区别：for没有调用额外的调用栈和上下文所以性能要优于forEach。
```

##### 24、深拷贝和浅拷贝的区别。

```javascript
浅拷贝:如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。浅拷贝是拷贝一层，深层次的引用类型则共享内存地址。常见的浅拷贝方法Object.assign()、扩展运算符、concat等。
深拷贝:两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。常见的深拷贝方法JSON.stringify(会忽略函数，symbol、undefined)、_.cloneDeep等。
```

##### 25、大文件上传如何做断点续传？

```javascript
大文件上传
1、按照一定的规则分割，分割成相同大小的数据块
2、初始化一个上传任务，返回本次上传的唯一标识
3、开始串行或并行上传分片数据。
4、发送完成后，服务端接收到数据后，根据切片标志整合成完成的数据。
断点上传
上传过程中，数据还未全部上传完成，将上传的文件作为临时文件保存，等待数据全部上传完成后将其改成正式文件。如果上传时，发生中断或者暂停，等待下次上传时，可以根据已经上传文件的偏移量来确定下一次的上传文件的位置。
```

##### 26、JS事件委托的理解。

```javascript
事件委托，会把一个或者一组元素的事件利用事件冒泡的机制委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素。这样做的好处减少重复代码，没必要每个元素都进行事件绑定和优化性能。
```

##### 27、require 具体实现原理。

```javascript
1、将相对路径转化为绝对路径。
2、判断是否有缓存，如果有缓存直接从缓存中获取，没有就执行下一步。
3、创建一个Module实例，实例主要属性包括(id：模块名、exports：模块输出接口，loaded：表示该模块是否执行完毕)，并缓存起来。
4、取出模块后缀，根据不同的后缀名调用不同的处理方法，如果是json文件，那么直接赋值给module.exports。 如果是js文件，将js内容进行包裹转化成真正的函数并执行，然后将结果赋值给module.exports。
tips：CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。
```

##### 28、for...in和for...of的区别？

```
for...of 是ES6新增的遍历方式，允许遍历一个含有iterator接口(数组、对象等)的数据结构，并且返回各项的值。
1、for...of遍历去的是对象的键值，for...in获取的对象的健名。
2、for...in 会遍历整个原型链可迭代的属性，因此性能较差，而for...of 只遍历当前对象不会遍历原型链。
3、对于数组的遍历，for...in会返回数组中所有可枚举的属性(包括原型链上可枚举属性)，而for...of只会返回数组的下标对应属性值。
```

##### 29、如何使用for...of遍历对象？

```
for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。
如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性并包含next方法，并返回{value:0,done}这样的数据结构。
```

##### 30、 如何判断一个对象是否属于某个类？

```javascript
1、使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
2、通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。
3、如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。
```

##### 31、a.b 和 a['b'] 的性能比较。

```js
通过词法拆分，利用@babel/parser将其转换成AST代码，如下
a.b
Token: [
  0: Token {type: TokenType, value: "a", …}
  1: Token {type: TokenType {label: ".", …}
  2: Token {type: TokenType, value: "b", …}
]

a['b']
Token: [
  0: Token {type: TokenType, value: "a", …}
  1: Token {type: TokenType {label: "[", …}
  2: Token {type: TokenType, value: "b", …}
  3: Token {type: TokenType {label: "]", …}
]
通过词法拆分可以看出，a['b']比a.b 数组长度长，因此在代码生成阶段(将AST转化成机器码)前者更快。
```

##### 32、JS错误类型以及如果处理错误。

```javascript
1、语法错误。
比如常见的单词拼写错误，中英文符号错误等，然后就是 语法错误是无法被 try-catch 捕获的，try-catch只能捕获同步错误。

2、同步错误。
同步错误指的是在js同步执行过程中的错误，比如变量未定义等，同步错误是可以被 try-catch给捕获到的。

3、异步错误。
异步错误指的是在异步操作中发生的错误，这些错误 无法被常规的 try-catch 块捕获 。在 JavaScript 中，当使用像 setTimeout 、fetch 或者 Promise 等异步函数时，它们会在执行过程中将错误捕获并存储起来，直到该异步操作完成后，错误才会被抛出。由于这些错误是在异步操作的上下文中发生的，并且不会阻塞主线程，因此无法使用常规的 try-catch 块捕获这些错误。异步错误的话可以用 window.onerror 来进行处理。

✨ window.onerror 方法可以全局捕获 JavaScript 错误，无论是同步代码还是异步代码。而 try-catch 仅能捕获同步代码中的错误。

4、promise错误
在使用 Promise 进行异步操作时，需要在链式调用中使用 catch 方法来捕获异步错误。在编写 Promise 时，最好在链式调用的末尾添加 catch 方法来处理错误，以及 在全局范围内添加对 unhandledrejection 事件的监听，以捕获那些未被处理的 Promise 错误 ,这可以确保在发生异步错误时能够及时捕获和处理。

5、资源加载错误
当加载资源（如图片、脚本、样式表等）时，如果出现了错误，比如服务器挂掉、网络断开等问题，这就被称为资源加载错误。您可以使用window.addEventListener 方法来捕获 error 事件。
```

#### ES6

##### 1、let、const、var的区别。

```javascript
var：存在变量提升，会导致相同名称的值被覆盖。且声明的变量为全局变量，并且会将该变量添加为全局对象的属性。
let：不会存在变量提升。有块级作用域，在同一个块级作用域下，声明相同的变量，会报错。
const：定义一个常量。作用和let差不多。如果定义的值是基本数据类型，那么该变量时不可被修改的。如果是复杂数据类型，对象里面的属性值是可以被修改的。因为const定义常量不变的是对对象引用的地址，而不是值不变。
```

##### 2、箭头函数和普通函数的区别？

```javascript
普通函数：1、能够使用new关键字来实例化对象。2、可以改变this的指向。
箭头函数：1、不能作为构造函数使用 2、没有原型对象，也没有arguements。3、this指向不会改变，即使使用apply、call、bind方法。不需要使用构造函数或原型对象，推荐使用箭头函数。箭头函数中的this指向是指向当前函数作用域所用的对象。

const obj = {
    name: 'ohaiyo',
    getName:()=>{
        console.log(this.name); //这个时候this就是指向obj所在作用域所用对象，因为obj是声明的全局变量，所以这里的this指向的是window
    }
}
```

##### 3、ES5和ES6继承有什么区别？

```javascript
ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。

ES6类的 prototype 属性和__proto__属性
1、子类的__proto__属性，表示构造函数的继承，指向父类构造函数。
2、子类prototype属性的__proto__属性，表示方法的继承，指向父类的prototype。

ES5实现继承
function Super() {}
Super.prototype.method = ()=> {}
function Child() {
    Super.call(this); // 父类构造函数继承
}
Child.prototype = Object.setPrototypeOf({},Super.Prototype); // 原型继承

ES6实现继承
class Child extends Super {
    constructor() {
        super();
    }
}
```

##### 4、ES6中装饰器Docorator的理解。

```javascript
装饰器是在不改变原有类和使用继承情况下，可以动态的扩展该类的功能。装饰器分为类装饰器和类属性装饰器。类装饰器可以接收一个参数，即类自身。类属性装饰器可以接收三个参数（类的原型对象、类的属性名称、属性名的描述）。如果方法有多个装饰器，那么就是由外到内进入，执行的时候由内向外。装饰器不能作用于函数，因为函数存在变量声明的情况会导致变量提升，使装饰器失效。
```

##### 5、Reflect和Proxy的用法。

```javascript
Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。
Reflect可以理解为Object的升级版。
1、让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj。
2、Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。
3、修改某些Object方法的返回结果，让其变得更合理。
Proxy在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。比较常用拦截操作
// target 表示目标对象。propKey表示拦截属性。receiver表示proxy实例本身。
1、get(target, propKey, receiver)：拦截对象属性的读取
2、set(target, propKey, value, receiver)：拦截对象属性的设置，返回一个布尔值。
3、has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
4、deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
```

#### 异步编程

##### 1、异步编程的实现方式？

```javascript
1、函数回调方式。语法不够简洁，且会造成地狱回调。
2、Promise。本质是上函数回调的升级版，只是改变回调的方式，通过使用then方法链式调用。如果嵌套请求层次过多，也会造成语义不明确，不便于调试。
3、generator。通过控制函数的执行权的方式，来实现异步编程。当遇异步函数时，将函数执行权转交给异步函数，等到该函数执行完成，在将控制权收回，继续执行后面的代码。需要一个自执行机制。
4、async/await。基于promise和generator实现的一种语法糖。当async函数遇到await关键字时，会等待await后面函数执行完成后，在继续执行后面的代码。
```

##### 2、对Promise的理解。

```javascript
Promise是一种异步解决方案。Promise有三个状态pending(进行中)、fulfilled(已成功)、reject(已失败)。且只能从pending到fulfillede或pending到reject。一旦状态改变就不会改变。
Promise有以下几个方法：
1、resolve。将对象转化为Promise对象。
2、reject。返回一个新的 Promise 实例，状态为reject。
3、all。接受一个Promise数组。只要其中Promise实例一个状态为reject，那么就会返回reject。所有Promise实例状态都为fulfilled，就会返回一个值数组。
4、race。接受一个Promise数组。返回一个率先改变状态的实例的返回值。
Promise有以下缺点。
1、一旦新建它就会立即执行，无法中途取消。
2、如果不设置reject回调函数，Promise内部抛出的错误，不会反应到外部，通过reject函数返回，可以使用catch方法捕获。
3、当处于pending状态时，无法得知目前进展到哪一个阶段。
```

##### 3、async/await和Promise的理解。

```javascript
async/await其实是Generator 的语法糖，都是协程的一种实现模式。async/await 是有栈协程，有独立的运行栈，Generator是 无栈协程，没有独立的运行栈。有栈协程从流程上的调度更容易控制，但它需要独立的内存空间，而无栈协程则相对于更节省资源。它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。
1、代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
2、错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
```

##### 4、属性的遍历。

```
1、for...in。遍历自身和继承的可枚举属性（不包含Symbol）
2、Object.keys(obj)。返回一个数组。包括对象自身的（不含继承）所有可枚举属性的键名。
3、Object.getOwnPropertyNames。返回一个数组，包含对象自身的所有属性(不含Symbol，但是包括不可枚举的属性)的键名。
4、Object.getOwnPropertySymbols。返回一个数组，包括对象自身的所有 Symbol的键名。
5、Reflect.ownKeys。返回一个数组，包含对象自身(不含继承的)所有键名。

属性遍历次序规则：
1、首先遍历所有数字键，按照数值升序排列
2、其次遍历所有字符串键，按照加入时间升序排列
3、最后遍历所有Symbol键，按照加入时间排序。
```

### Vue2.0

------

#### Vue基础

##### 1、Vue的基本原理。

```javascript
当创建一个实例时，Vue会遍历data中的属性，通过使用Object.defineProperty()方法将data中的属性转化成get/set，并在内部记录相关依赖，在属性被访问和修改时发生变化。每一个组件实例都有对应的watcher实例，会在组件渲染过程中记录依赖。当依赖项的set被调用时，就会通知watcher重新计算，从而使其关联的组件得以更新。
```

##### 2、双向绑定的原理。

```javascript
采用数据劫持和发布者-订阅者的设计模式。
对象劫持
对象劫持主要涉及Observer类。是通过Object.defineProperty()来劫持各属性的get，set。get用来收集相关依赖，set则是用来触发视图更新。对于数据劫持分为对象类型和数组，对象类型直接递归遍历其属性直接设置get、set。而对于数组的劫持采用AOP(切片思想)。即对数组原型对象进行重写(push、pop、shift、unshift、sort、splice、reverse)。对数组进行劫持不是对每个元素的属性进行劫持而是对每个元素进行劫持，对元素属性劫持开销太大，而且大部分场景下，只是对数组进行遍历，这相当于是一种优化。
发布者-订阅者
1、Complie解析模板，在初始化页面渲染时，在每个指令的节点绑定更新函数，添加数据的订阅者。一旦数据变化，通知订阅者，触发更新。
2、Watcher订阅者是Observer和Compile之间通信的桥梁。Dep类作用添加订阅者和发布消息，Watcher类作用是收集依赖，每个组件都会有一个watcher实例，当实例化这个对象时，会触发构造函数中的get()方法，在过程中又会触发Dep类中的addSub()和depend()方法(劫持数据过程中每个属性都持有一个dep对象)，将当前watcher添加到subs数组。等到数据发生变化，就会调用dep.notice()发送通知，然后调用自身的update方法，并触发complie中的回调函数。
3、通过Observer监听自身model数据，complie解析对应的编译模板指令，Watcher搭起Observer、Complie之间的桥梁，最终实现双向绑定。
```

##### 3、MVVM、MVC的区别。

```javascript
MVC:M表示Model层，用来存储页面交互的数据。V表示View即视图层。C表示Controller即控制层，用来处理业务逻辑。用户通过View视图触发事件，通知Controller，然后Controller处理完成后，通知到Model，最后由Model层通知到View层，实现视图更新。
MVVM：M表示数据模型层。用来定义数据模型。V表示视图层。VM是ViewModel。是用来链接Model层和View层的桥梁，当View层发生变化通过ViewModel也会引起Model层的改变。反之Model层改变也会通过ViewModel引起View的改变。
```

##### 4、Computed、Watch、Methods的区别。

```javascript
Computed:计算属性。Computed的值具有缓存。只有当依赖的值发生变化时，才会重新执行。不支持异步。
Watch:监听器。不具有缓存。当监听的数据发生改变时，会触发watch对象里面的方法进行回调操作。支持异步。
Methods:和计算属性差不多。但是Methods方法总是会调用执行。
```

##### 5、slot作用以及原理。

```javascript
slot分为匿名插槽、具名插槽、作用插槽。
匿名插槽：默认的插槽。
具名插槽：通过指定slot的name属性，可以在指定的地方插入内容。
作用插槽：通过将子组件的值传递父组件，以此来自定义插槽的渲染内容。
当组件被vm实例化时，会生成一个vm.$slot 的对象，该对象就是插槽对象。默认就是vm.$slot.default 匿名插槽。具名插槽就是vm.$slot.name(定义的插槽name)。在视图渲染时，此时可以传递参数，这就是作用插槽。然后再slot对象替换成插槽的内容即可。
```

##### 6、data为什么是一个函数而不是一个对象？

```javascript
为了解决数据混乱的问题。在组件内部，如果data是一个对象，当引用该组件改变data里面某个属性的值时，其他引用改组件的data值也会也会发生变化。如果是一个函数，就相当于是值引用，不会造成数据混乱的问题。
```

##### 7、Vue.$nextTick原理及作用。

```javascript
$nextTick是往队列中添加回调函数，采用优雅降级promise->mutationObserver->-setImmediate>setTimeout微任务优先的方式调用异步方法去执行 nextTick 包装的方法。它的作用就是某些场景需要进行DOM操作时，就使用该方法，将其加入Vue的异步队列中，如果是重复的任务，只会添加一次到异步队列中。引入异步队列的原因其实比较简单就是为了性能优化，如果是同步的话，对一个值多次赋值，会频繁的触发UI/DOM渲染，造成没必要的性能浪费。
```

##### 8、单页面(SPA)与多页面(MPA)的区别。

```javascript
SPA
1、用户体验好、快，内容的改变不需要重新加载整个页面。
2、前后端分离，增大解耦性
3、不利于SEO（可以通过服务端渲染和URL Rewrite的方式来实现SEO）。首屏加载慢，因为要一次性将所有公共资源加载完成。
MPA
1、多页面应用程序。多个页面，每次页面跳转都会重复加载公共的资源文件，且会刷新页面，用户体验不好。但是利于SEO。
```

##### 9、Vue data中某个一个属性值发生改变后，试图会立即更新吗？

```javascript
不会立即更新。Vue的DOM更新是异步的，只要监听到数据的变化，就会开启队列，并将其加入到队列中，同一个属性发生多次改变，只会添加一次进入队列(去重)。来达到性能优化的目的。等到下一次事件循环tick，就会执行去重后的代码。
```

##### 10、对React和Vue的理解，它们的异同。

```javascript
相同点
1、数据驱动视图
2、组件化思想
3、都有虚拟DOM
4、支持服务端渲染
不同点
虚拟DOM：
	Vue：当组件属性发生变化时，不需要渲染整个组件，只渲染改变部分。
	React：当组件属性发生变化时，整个子组件会重新渲染。
监听数据变化：
	Vue：采用数据劫持-发布订阅的模式。
	React：比较数据之间的引用是否发生改变，
组件化：
	Vue：template模板，更加贴近HTML原生写法。
	React：JSX语法。
高阶组件:
	Vue:通过mixins来扩展组件。
	React：通过HOC来实现高阶组件。高阶组件本质上就一个函数，因此React实现起来相对于更容易些。
```

##### 11、Vue 模板编译原理。

```javascript
主要分为两个步骤生成AST树和将AST转化成render函数。
生成AST树利用正则表达式匹配标签的开头和结束以及标签名属性，根据解析出来的结果生成AST，并检查是否合法，如果不合法，则抛出异常。
AST转化成render函数则是将传入的AST转化成函数字符串类似于Vue.createElement()函数创建组件的结构，然后使用new Function结合with(this)的方式,使用with改变作用于this，是为了后面的调用可以通过call改变this的指向，最后再返回该结果。
```

##### 12、Vue的优缺点。

```javascript
优点：
1、双向绑定
2、提供响应式和组件化视图
3、使用虚拟DOM
4、轻量级框架
缺点(相比于react):
1、JSX与template。JSX语法可以使用完整的JS语法来构建页面。比如可以使用临时变量、条件控制语句等。
2、原生渲染。React Native 相比于 week 更加成熟。
```

##### 13、Vue是如何收集依赖的？

```javascript
初始化vue组件实例时，会对组件中的data进行数据劫持，为每个data属性添加对应的get/set，其中get部分就是用来收集依赖的。收集依赖主要有两个类Dep和Watcher。

Dep Class的主要作用是添加订阅者和发布消息(收集依赖的核心)，Dep Class有一个关键的静态属性target，它指向了全局唯一的Watcher，保证同一时间全局只有一个Watcher参与计算。另一个属性 subs 则是一个 Watcher 的数组。

Watcher类作用就是收集相关依赖。
每个组件都会有一个watcher实例，当实例化这个对象时，会触发构造函数中的this.get()方法，将Dep.target 赋值为当前的watcher。在这个过程中会触发数据对象的getter，每个数据对象都会持有一个dep，在触发getter时候会调用dep中depend()addSub()方法，将当前的watcher订阅到Dep的订阅列表中。当监听数据发生变化时,会触发Ddep.notify()方法，然后通知对应的订阅者，实现对应的操作。
```

```javascript
class Dep {
  // 全局唯一watcher
  static target;
  // 订阅者数组
  subs;
  // 添加订阅者
  addSub (sub) {
    this.subs.push(sub)
  }
  // 收集依赖
  depend () {
    if(Dep.target){
      Dep.target.addDep(this)
    }
  }
  // 通知订阅者
  notify() {}
}

class Watcher {
  constructor (vm, expression){
    this.getter = expression;
    this.get();
  }
  get () {
    pushTarget(this);
    value = this.getter.call(vm, vm)
    ...
    return value
  }
  addDep (dep){
        ...
    dep.addSub(this)
  }
}

function pushTarget (_target) {
  Dep.target = _target
}
```

##### 14、如何理解Vue渐进式框架？

```javascript
所谓的渐进式主张问题少，没有那么多的硬性要求。Vue可以逐渐增强使用，可以单独在网页中局部使用vue或者可以全局使用工具搭建vue项目。可以根据项目需求不同来添加不同的部件，如果路由，状态管理等且这些部件相互独立，不会耦合在一起。相比于React和Angular，Vue的主张更少，比如React主张函数式编程，Angular主张模块机制和依赖注入等。
```

##### 15、如何保存页面的当前的状态。

```javascript
1、LocalStorage / SessionStorage。通过JSON序列化来存储组件的数据，简单方便，但是这种方式对于一些特殊的对象是无法使用的，比如Date对象。
2、路由传值。通过query将参数放在url后面。但是这种方式如果组件多级嵌套，那么嵌套的组件都需要相同的逻辑代码。
3、keep-alive。使用keep-alive包裹组件的方式来缓存状态。当被包裹的组件切换时会触发activated、deactivated两个生命周期。
```

##### 16、常见的事件修饰符及其作用。

```javascript
1、prevent。等同于event.preventDefault() ，阻止默认事件。
2、stop。等同于event.stopPropagation() ，防止事件冒泡。
3、once。只会触发一次。
4、slef。只触发自身事件，不会触发子元素事件。
```

##### 17、defineProperty和proxy的区别。

```javascript
 defineProperty
 1、当对象新增或者删除属性时，vue无法检测的，只能通过this.$set的方式手动去添加更新。
 2、无法监控到数组的长度或者下标的变化。
 proxy
 1、直接代理的是整个对象而非对象的属性，只需要做一次代理就能够检测到属性的变化。
 2、可以监听的数组的变化。
 3、vue3使用proxy，支持Map、Set等数据结构。
 4、vue3不需用使用Vue.$set 或 Vue.$delete 触发响应式。
```

##### 18、Vue 指令是什么？作用是什么？

```javascript
Vue指定本质上是一个装饰器，是 vue 对 HTML 元素的扩展，增加其扩展功能，Vue指令分为全局指令和局部指令。自定义指令有五个声明周期。
bind：只调用一次。初始化的时候调用，用来进行参数设置。
inserted：被绑定元素插入父元素时触发。
updated：被绑定元素更新时触发，无论绑定值是否发生变化。
componentUpdated：被绑定元素所在模板完成一次更新时触发。
unbind：只调用一次，绑定元素解绑时触发。
```

##### 19、Vue.mixin是什么？

```javascript
Vue.mixin 是vue用来实现高阶组件的一种方式，使其可以用来抽离公共的业务逻辑，类似于'对象的继承'。当组件初始化时，会调用 mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。合并策略如下：
1、mixin生命周期与组件内生命周期重名时，会合并成一个数组，依次执行。
2、mixin属性和组件内属性重名时，以组件内的属性为准。
```

##### 20、Vue.extend是什么？

```javascript
Vue.extend 提供了一个Vue的构造函数，创建并返回一个vue实例。其实现原理调用VueComponent方法，得到一个子类的构造函数，将该构造函数的prototype属性指向Vue的原型对象和该constructor指向自己(VueComponent初始化指向Vue)，最后进行参数合并 ，返回该子类对象。使用Vue.extend()创建的实例，需要手动挂载才会生效，然后传递参数需要用propsData对象，而不是props对象。
```

##### 21、v-if和v-show的区别？

```javascript
控制手段：v-show只是单纯的控制css属性display的值来控制是否显示。dom元素依旧存在。v-if则是将整个dom元素新增或者删除。
编译条件：v-if是真正的条件渲染，在切换过程中组件会被销毁和重建。会触发完整的生命周期，而v-show则不会触发生命周期。直接
性能条件：v-if性能相对于v-show要高。因为直接对dom进行新增或删除操作。
```

##### 22、为什么Vue中的v-if和v-for不建议一起用?

```javascript
v-for的执行优先级比v-if要高，如果在v-if和v-for用在同一个元素上，那么每次都会先执行v-for，然后再执行v-if，造成了不必要的性能开销。可以将v-if作用于在v-for元素的父元素上。
```

##### 23、对keep-alive的理解以及其原理。

```javascript
keep-alive是Vue内置的一个组件。在组件切换时，如果需要保存组件的状态，可以使用keep-alive包裹该组件。被keep-alive搭配使用的一般是动态组件和router-view且只对第一个组件有效。它有三个属性include（名称匹配会被缓存）、exclude（名称匹配不会被缓存）、max（组件最大缓存数量）。其实现步骤如下：
1、判断组件name是不在include或在exclude。就直接返回vnode。说明该组件不被缓存。
2、获取组件的实例key，如果组件没有key，则通过cid+元素类型重新生成key。因为相同的构造函数可以被注册成不同的组件。
3、通过key值获从缓存对象中获取组件实例，如果存在，就将缓存对象赋值给vnode。不存在，就将入到缓存对象中。
4、当缓存组件数量超过max时，清除掉缓存对象内第一个组件。
```

##### 24、父组件和子组件的执行顺序？

```javascript
渲染
父create->子created->子mounted->父mounted。
更新
父beforeUpdate->子beforeUpdate->子updated->父updated
卸载
父beforeDestory->子beforeDestory->子destory->父destory。
父组件优先实例化，等到子组件挂载完成，父组件才挂载。
```

##### 25、Vue.set 方法原理？

```javascript
在vue中，在实例创建之后新增的属性和修改数组下标来修改值是无法触发响应式更新的。因此需要set方法，将对象属性转化成响应式的。 实现原理如下：
1、判断是否是数组，如果是数组则直接调用数组的splice方法，因为splice被重写过，支持数据响应式
2、如果是对象并且属性在目标元素或目标元素的原型上，则可以直接修改。
3、如果以上条件都不满足，就获取目标元素的_ob_属性，如果存在该属性，就调用defineReactive方法对数据进行响应式拦截并调用notify方法通知依赖项进行更新。如果没有该属性，则说明不是响应式数据，直接赋值即可。
```

##### 26、Vue初始化都做了什么？

```javascript
1、参数合并，将传入的参数与函数本身的构造函数合并，
2、执行initLifecycle方法初始化生命周期相关属性。
3、执行initEvents方法初始化自定义组件事件的监听。比如on、off等。
4、初始化render所需的插槽和渲染函数等。
5、调用beforeCreated钩子函数。
6、初始化注入inject参数，父组件注入参数，后代组件就可以通过provide来获取参数。
7、执行initState方法初始化组件内属性。按照props->methods->data->computed->watch的顺序初始化各属性。
8、初始化provide参数，在后代组件中获取祖辈组件注入的参数。
9、调用created钩子函数，初始化完成，可以执行挂载了。
10、挂载到对应的DOM元素上。如果构造函数设置el属性，就会自动挂载，否则就需要调用mount手动挂载。
```

##### 27、delete和Vue.delete删除数组的区别？

```javascript
1、delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。
2、Vue.delete 直接删除了数组 改变了数组的键值。
```

##### 28、Vue的性能优化有哪些？

```javascript
编码阶段
1、v-if和v-for不能同时作用于一个组件。
2、SPA页面采用keep-alive缓存组件。
3、v-for循环key值必须唯一。
4、第三方模块按需导入
5、尽量减少data中的数据，data中的数据会增加getter和set，会收集对应的依赖，如果逻辑较为复杂的组件建议拆分为多个组件。
SEO优化
1、服务端渲染SSR。
打包优化
1、压缩代码。
2、splitChunks抽取代码公共模块。
3、使用tree shaking(摇树优化)，对于那种未使用的方法和变量打包时会删除掉。
4、开启多线程打包happypack。
用户体验
1、使用骨架屏加载。
2、使用图片懒加载。
```

##### 29、Vue组件通信方式？

```javascript
父子组件通信
1、props/$emit。父组件通过props向子组件传递数据，子组件通过$emit和父组件通信。
2、ref/$refs。通过设置子组件ref，父组件通过refs属性来访问子组件实例来获取子组件信息。
3、$parent/$children。$parent可以访问上一级父组件实例，$children子可以访问子组件的实例。但是，$children并不能保证顺序，并且访问的数据也不是响应式的。
非父子组件通信
1、eventBus事件总线。
2、依赖注入（project / inject）。
3、$attrs/listeners。$attrs表示继承所有的父组件属性，$listeners包含了作用在这个组件上的所有监听器,比如事件等。
```

##### 30、data属性为什么能直接通过this.访问?

```javascript
采用proxy代理方法，vue在初始化data时会调用proxy方法，将data中的key值直接放在vm实例上，当我们通过访问this.xx 其实访问的是this._data.xx 属性的值。

// sourceKey 这里是data
function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxyset (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
```

##### 31、Vue中封装的数组方法有哪些，其如何实现页面更新？

```
数组则是通过对数组原型七个的方法(pop,shift,unshift,push,reverse,sort,splice)进行拦截和劫持数组的每项值来实现。这里不对数组里面元素的每个属性进行劫持，是出于性能考虑，而一般开发者使用数组都是遍历。通过在数组上面定义_ob_属性，该属性是一个Observe实例，用来标记是否数据是响应式数据而不必要重复实例化和响应数据可以使用_ob_来获取Observer实例上的方法，比如notify发布消息等。
```

##### 32、Vue如何捕捉异常错误？

```
一般错误分为接口请求错误和代码本身逻辑错误。

接口请求错误
通过axios的interceptor实现网络请求的response先进行一层拦截，在error回调函数中进行对应的逻辑操作。比如400、403、500错误等。

代码本身错误
1、全局设置错误处理。通过Vue.config.errorHandler指定组件的渲染和观察期间未捕获错误的处理函数。
2、生命周期钩子。errorCaptured当捕获到一个来自子孙组件的错误时被调用。如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler，可以通过返回false来阻止错误继续向上传播。
```



#### 生命周期

##### 1、Vue生命周期有哪些。

```javascript
beforeCreated:组件实例创建之前。用于一些任务的初始化。
created:组件实例创建完成。此时渲染节点还未挂在到DOM，不能访问虚拟DOM。
beforeMounted:开始挂载之前。render函数首次被调用，能够访问到虚拟DOM。
mounted:挂载完成。将虚拟DOM替换成真实的DOM。可以访问到真实的DOM元素。
beforeUpdate:组件更新之前。发生在虚拟DOM重新渲染和打补丁之前，在这个过程中可以修改状态，并且不会触发附加的渲染过程。
updated:更新完成。组件的DOM更新完成。避免在该阶段修改数据，可能会造成无限的循环更新。
beforeDestroy:组件销毁之前。能够访问到this对象，可以在此生命周期做一些释放对象内存的操作。
destory:组件完成销毁。
activated keep-alive 专属，组件被激活时调用。
deactivated keep-alive 专属，组件被销毁时调用。

tips：建议在数据请求放在created中，因为此时真实的DOM还未生成，不会造成闪屏的问题。
```

#### 路由

##### 1、路由hash和history模式的区别。

```javascript
hash：通过监听onhashchange事件去监听hash是否发生变化来实现对应的内容切换。hash值会出现在url里面，但是不会出现在http请求中，因此修改hash值不会重新加载页面。
history：通过监听onpopstate事件来实现该路由。修改url，服务端会重新解析这个请求，因此服务端需要做一些配置。比如用户输入错误的地址，如果没有做出相应配置，那么页面就会报错了。
```

##### 2、路由的传参方式以及区别。

```javascript
1、query方式传参。通过$route.query()获取。这种方式传参参数会出现在url中，刷新页面参数不会消失。
2、param方式传参。通过$route.param()获取。这种方式参数是通过body传递过去，不会出现在url中，刷新页面参数会丢失。
```

##### 3、Vue-Router钩子有哪些？

```javascript
1、全局导航
	beforeEach:进入路由之前。可以用该钩子实现登录拦截功能。
	afterEach:进入路由之后。
2、路由导航。
	beforeEnter:如果不想配置全局导航，可以在路由导航里进行单独配置。
3、组件导航。
	beforeRouteEnter：进入组件之前触发的钩子。
	beforeRouteLeave：离开组件触发钩子。
	beforeRouteUpdate：路由改变时触发的钩子。比如路由参数发生变化等。
```

#### Vuex

##### 1、Vuex的原理以及理解。

```javascript
vuex是一个状态管理的工具。其中vuex包含以下几个属性。
state：页面状态管理容器对象，用来定义响应式数据。
commit：状态改变提交数据的方法。对mutation进行提交，是唯一能提交执行mutation的方法。
mutation：Vuex推荐唯一能改变state数据的方法。该操作是同步的，且方法名只能为全局唯一。
actions：支持异步操作改变state属性。action提交的是mutations，而不是直接改变状态。按照注册的顺序依次触发，支持多个同名方法。在视图更新时新触发actions，action触发在触发mutation。
dispatch：操作行为方法。唯一能执行action的方法。
getters：类似于computed(是一个东西，可以通过mapGetters获取)属性，通过对state进行处理，返回处理后state数据。
modules：模块划分。

原理：
Vuex本质上是一个对象，有两个属性，一个是install方法，一个是Store类。install方法作用就是将store作用于所有的组件上，Store类作用就是提供一些属性、方法等。Vuex原理可以分为以下几点：
1、给每个实例注入$store。在vue.install()方法里面利用vue.mixins()混入，在beforeCreated钩子函数中，给组件新增一个store属性。
2、利用new Vue设置state响应式数据。
3、getters。遍历state属性，利用Object.defineProperty()给每个属性都添加get()方法，这样我们获取属性值的就不用去调用方法了，而是直接对象.属性名 的方式。

tips：可以通过mapState、mapget、mapMutation、mapAction来帮助我们调用vuex store。
tips:为什么用get的时候不用写括号？
A:因为get的实现是利用了Object.defineProperty()将get对象中的所有属性加上get方法。获取值得时候就相当于直接调用get方法，因此不需要些括号。
```

##### 2、Vuex和单纯的全局对象有什么区别？

```javascript
Veux是响应式。当store state里面的值发生改变时，视图也会做出响应的变化。而全局对象则不会。
在非严格模式下是可以直接改变store的状态。但是这样会造成无法跟踪每一个状态的变化，当报错时，不便于调试。所以不推荐直接改变store的状态。
```

##### 3、为什么Vuex的mutation中不能做异步操作？

```javascript
Vuex改变状态的唯一途径都是mutation。异步操作Action也是通过提交mutation来改变状态。这样更加方便我们追踪每个状态的变化，便于调试。如果mutation支持异步操作，那么就无法区别是由Action 提交的mutation还是由commit提交mutation。
```

#### 虚拟DOM

##### 1、对虚拟DOM的理解？

```javascript
虚拟DOM其实就是一个JS对象，用来描述真实DOM结构的对象。配合不同渲染的工具，使跨平台具有可能性。通过处理事务机制(比如异步队列)，将多次的DOM修改的结果一次性渲染到页面上，而不用大量去操作DOM元素，引起不必要重绘和重排，提高性能。但是虚拟DOM的效率不一定比修改DOM要高，这个要看场景区分。比如只是修改一个div的文本信息，肯定是用直接操作DOM修改要快的，因为虚拟DOM还要经过Diff算法，才能渲染到页面上。
缺点：对于一下性能要求较高的项目无法进行极致优化。
```

##### 2、虚拟DOM解析过程。

```javascript
1、解析文档的DOM结构，用JS对象将其保存起来。
2、当页面状态发生改变之后，根据改变后的状态，新建一个对象树，然后与之前的对象树进行比较。记录其差异。
3、将其差异的对象树转化成真实DOM树。
```

##### 3、Vue Diff算法的原理。

```javascript
1、当修改数据时，触发set属性Dep.notify()方法通知对应的订阅者，然后调用patch(oldNode,newNode)方法进行比对。
2、调用isSameVNode方法判断新旧节点是否是相同类型标签，如果是不同类型标签，则直接替换。相同类型标签则进行下一步比较。
3、调用patchNode方法判断新旧节点是否相等，如果相等直接返回，不等则进行下一步比较。
4、判断新旧节点都有文本节点，用新文本替换旧文本。
   旧节点没有子节点，新节点有子节点。需要增加新的子节点。
   旧节点有子节点，新节点没有有子节点。需要删除旧的子节点。
   新旧都有子节点，需要调用updateChildren方法进行比较。
5、updateChildren采用首尾指针方法对比方法，只对比同级节点，提高对比效率。
   每个节点都有start点和end点，用旧节点start点和end点去比对新节点的start或end点，每次比较成功后，start点和end点都会向中间靠拢，当新旧节点中有一个start点跑到end点右侧后，就终止比较。
   如果上述情况匹配不到，则需要用旧节点key值去比对新节点key值，如果key值相同则复用，并将旧节点移动到新节点位置。
```

##### 4、Vue中key的作用。

```javascript
1、强制渲染。在v-if，如果切换的是相同类型的元素，那么这个元素就被复用。如果添加了key，这个元素就被标记为唯一，在此切换组件，就不会被复用了。
2、提高虚拟DOM渲染效率。在v-for中使用key，相当于为每个元素添加了唯一标识。当数组发生改变，Diff算法直接通过key找到每个元素，而不用去遍历递归，从而提高虚拟DOM渲染效率。
```

### Vue3.0

##### 1、Vue3.0有什么更新？

```javascript
性能提升
使用proxy替代Object.defineProperty。
1、检测属性的添加和删除。
2、检测数组索引和长度的变更。
3、支持 Map、Set、WeakMap 和 WeakSet。
模板
1、作用域插槽。Vue2作用插槽会改变后，父组件也会重新渲染。Vue3采用函数的方式，这样只会影响子组件的重新渲染，不会影响到父元素。
新增组件
1、Fragment可以允许有多个根节点。
2、Teleport允许在任意DOM中新增节点。
3、Supense支持异步组件。
其它
1、支持Fragment(多个根节点)和Protal组件。
2、支持摇树优化。打包时，将不需要模块修剪掉，不会打包进模块中，加载速度更快。
3、更好的支持 typeScript。
```

##### 2、Vue 3.0 中的 Vue Composition API和Vue 2.0中的Options API的区别？

```javascript
Options API 通过填充(data、methods)等属性来完成一个vue组件，这种风格使得vue更加容易上手，但是也造成几个问题.
1、开发方式不够灵活，使得vue开发缺少更加优雅的方式在组件间共用代码。
2、Vue过分依赖this上下文。在vue组件中默认的this是指向当前v组件实例，使得 TypeScript 在Vue2 中很不好用。
Composition API
1、本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。
```

##### 3、Composition API与React Hook的区别？

```javascript
React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制。
1、不能在循环、条件、嵌套函数中调用Hook。
2、必须确保总是在React函数顶层调用Hook。
3、useEffect、useMemo等函数必须手动声明依赖。
是基于Vue的响应式系统实现的，与React Hook的相比有以下优势。
1、声明在setup函数内，一次组件实例化只会调用一次setup，不像React Hooks每次重新渲染都需要调用Hook，造成额外的性能开销。
2、调用不需要考虑顺序，时序等。
3、响应式系统实现了依赖自动收集，不需要手动传入。React Hook则需手动传入依赖且必选保证顺序，否则可能会适得其反，使组件性能下降。
```

##### 4、watch 和 watchEffect 的区别？

```javascript
watch 和 watchEffect 都是监听器,watchEffect是一个副作用函数。区别如下
1、watch需要手监听的数据源，watchEffect可以自动收集数据源作为依赖项。
2、watch可以获取到改变前后的值，watchEffect 只能获取改变后的值。
3、watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。
```

##### 5、script setup 是干啥的？

```javascript
scrtpt setup 是 vue3 的语法糖。使用 script setup 语法糖的特点。
1、属性方法无需返回，可以直接使用。
2、引入组件的时候，会自动注册，无需通过components注册。
3、使用 defineProps 接收父组件传递的值。(不适用setup语法糖,setup(props，context)需要用到props属性)。
4、useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。
5、默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。
```

##### 6、vue3做了哪些优化？

```
更小
    Vue3移除了一些不常用的API，引入了tree-shaking，可以将无用模块剪辑，仅打包需要的，使打包的整体体积变小了。

更快
    diff算法优化
    静态提升
    事件监听优化缓存
    SSR优化

更友好
	 Vue3在兼顾Vue2的options API的同时还推出compostion API，大大增加了代码的逻辑组织和代码复用能力。
	 
源码管理
		Vue3整个源码是通过monorepo的方式维护，根基功能不同的莫夸拆分到packages目录下不同的子目录中。
```

##### 7、Vue3.0性能提升主要是通过哪几方面体现的？

```
回顾 Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件染的过程中把用到的数据 property 记录为依赖，当依赖发生改变，触发 setter ，则会通知 watcher，从而使关联的组件重新渲染。无论组件内部有多个动态节点，都是所有节点都需要重新遍历，造成性能浪费。

1、Diff算法优化
	Vue3在diff算法中相比Vue2增加静态标记，关于这个静态标记，起作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较，对于标记静态节点在diff过程中则不会比较。
2、静态提升
	Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在染时直接复用这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用。
3、SSR优化
	当静态内容大到一定量级时候，会用 createStaticVNode 方法在客户端去生成一个static node，这些静态 node，会被直接 innerHtml，就不需要创建对象，然后根据对象渲染
4、源码体积
	相比 Vue2， Vue3 整体体积变小了，除了移出一些不常用的API，再重要的是 Tree shanking任何一个函数，如 ref、reavtived、computed 等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。
5、响应式系统
	vue2中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter 和 setter，实现响应式
vue3采用 proxy重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历
    。可以监听动态属性的添加
    。可以监听到数组的索引和数组 length 属性
    。可以监听删除属性

```

### React

------

#### 组件基础

##### 1、React的事件机制。

```javascript
React事件是合成事件，并不是将事件绑定给到真实的DOM上，React会把所有的事件绑定到结构的最外层(document)，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。这样做的好处为了减少内存和在组件销毁的时候取消事件的订阅。使用合成事件的好处跨浏览器，统一事件处理机制(避免事件频繁的新增与删除，减少性能消耗)。冒泡至document事件不是原生事件，而是React的合成事件。因此要阻止事件冒泡不能使用event.stopPropagation, 而是使用event.preventDefault。
```

##### 2、对React-Fiber的理解，它解决了什么问题？

```javascript
Fiber是React 16中新增的一种核心算法。它的作用支持虚拟DOM的增量渲染。在之前的版本中，渲染是，需要通过diff算法找出变动的节点，同步更新它们。这个过程React会占住浏览器资源，用户触发的事件得不到响应，会出现卡顿现象。所以React通过fiber，让这个过程变得可中断、暂停、继续，在适当的时候将控制权让给浏览器，让浏览器执行优先级更高的任务，等到浏览器空闲时，在恢复执行暂停的任务。这样浏览器就能及时响应用户的操作了，提高了用户的体验。
```

##### 3、React.Compoent和React.PureComponent的区别。

```javascript
React.Compoent： 表示一个组件。
React.PureComponent： 表示一个纯组件。它默认的执行了shouldUpdate生命周期，将数据进行浅比较，判断组件是否需要重新渲染。从而减少组件render的次数，达到提高组件性能的目的。
```

##### 4、React 高阶组件是什么，和普通组件有什么区别，适用于什么场景？

```javascript
React高阶组件本质上是一个函数。通过将其他组件当参数传递进去，进行逻辑操作后，返回一个新的组件。
HOC的好处：
1、代码复用、逻辑抽象
2、渲染劫持。比如可以通过HOC实现一个显示错误的组件，当页面报错，就会被该组件拦截，然后对错误信息进行处理。
```

##### 5、哪些方法会触发React重新渲染？重新渲染会做什么？

```javascript
1、调用setState方法。 调用setState会触发render函数，但是执行setState不一定会触发render，比如setState(null)时，就不会触发render。
2、父组件重新渲染。只要父组件重新渲染，那么子组件全部会重新渲染，即使父组件传递给子组件参数未发生变化。
重新渲染时会进行diff算法。首先会比较新旧VNode树，然后递归遍历新旧树，将其差异放入到一个对象中，最后遍历差异对象，根据规则去更新对应的VNode。
```

##### 6、React如何判断什么时候渲染组件？

```javascript
组件可以通过改变props或通过setState方法来改变状态。只要组件的state发生变化，React就会重新渲染，这是因为shouldUpdate默认返回的是true。因此可以通过该生命周期来决定是否要渲染组件。
```

##### 7、React中什么是受控组件和非受控组件。

```javascript
受控组件:表单元素的值需要React管理，获取组件的值就必须编写事件处理函数。比如Input输入框，React通过监听onChange事件，然后再去更新state的值。
非受控组件:表单元素的值由自身去管理部依赖React。可以通过ref来获取DOM表单的值。
```

##### 8、对React context的理解。

```javascript
context是React提供一种数据共享的方式，当我们需要跨层级传递参数可以使用该方式。通过Provider注入需要传递的参数，然后在需要组件的使用Consumer接受参数即可。React提供的Context对象就是就给子组件提供了一个作用域，而Context上的属性可以看成活动对象。所以组件可以通过Context访问到父组件链上所有节点提供的Context属性。但是当如果其中的一个中间件shouldUpdate返回的是false，那么其后面的组件将不在接受context的变化而触发render。
```

##### 9、类组件与函数组件有什么异同？

```javascript
相同点：组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素
不同点：
1、类组件面向对象编程。函数组件是函数式编程。
2、类组件通过shouldUpdate优化性能。函数组件通过useMemo优化性能。
3、如果需要使用生命周期，那么使用类组件。反之则使用函数组件。
```

##### 10、对React的插槽(Portals)的理解，如何使用，有哪些使用场景。

```javascript
Portals是将组件渲染到组件以外的DOM节点的方法。该方法有两个参数。
第一个参数child要渲染的内容。
第二个参数container是一个DOM元素，表示要渲染组件的位置。
使用场景：如消息提示框、对话弹框等。
```

##### 11、React中的props为什么是只读的？

```javascript
React提倡单向数据流。只能从父组件到子组件。且React具有浓厚的函数式编程思想，从本质上来说，函数式组件就是一个纯函数，对于纯函数有以下几个特点。相同的输入得到的是相同的输出，无副作用。如果this.props 变为可修改那么函数的输出可能就不一样了，破坏了纯函数的特点，因此props是只读的。
```

##### 12、在React中如何避免不必要的render？

```javascript
1、shouldComponentUpdate 和 PureComponent。在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。
2、利用高阶组件。在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能。
3、React.memo。用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。
```

##### 13、React.forwardRef是什么？它有什么作用？

```javascript
React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。
1、转发 refs 到 DOM 组件。
2、在高阶组件中转发 refs。
```

#### 数据管理

##### 1、React setState调用原理。

```javascript
当我们调用setState更新state时，并不会立即更新state的值，而是将新的state放入更新队列中，然后判断是否是批量更新，如果是批量更新，那么将其放入等待队列中等待下一次的批量更新。如果不是批量更新，则更新state的值，并渲染视图。
```

##### 2、React setState调用之后发生了什么？是同步还是异步？

```javascript
在代码中调用setState方法后，React会将传入参数与当前组件状态合并，然后进行diff算法，比较新旧树的差异，并自动记录其差异。如果在短时间内频繁setState，React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。
setState同/异步是根据场景而决定的。
异步场景：在React可以控制的地方。比如React在生命周期和合成事件中，都会走合并策略，延迟执行。
同步场景：在 React 无法控制的地方，比如原生事件，如setTimeout等。
```

##### 3、在React组件的this.state和setState有什么区别。

```javascript
setState本质是通过一个队列机制实现state更新的。用setState时，会将修改的state放入到队列中。出于性能考虑，多次的setState调用，最后会合并成一次调用。而this.state 其本质没有将修改放入队列中，所以也不触发render。
```

#### 生命周期

##### 1、React的生命周期有哪些？

```javascript
React生命周期分为三个阶段。
1、装载阶段。
2、更新阶段。
3、卸载阶段。
componentWillMount:在render之前执行。
componentDidMount:组件挂载完成后。用来获取网络数据，执行DOM操作等。
componentWillUpdate:组件更新之前。
componentShouldUpdate:组件是否应该更新，可以通过返回true或false，来决定是否渲染组件。
componentDidUpdate:组件更新完成。
componentWillUnmount:组件将要卸载。可以用来取消事件的订阅或者释放内存。
componentDidCatch:组件发生错误时，出触发该生命周期。可以用来捕获异常信息。
tips：现在都推荐函数组件加hooks的写法了，因此生命周期可以被忽略了。
```

#### 组件通信

##### 1、组件之间的通信方式有哪些？

```javascript
父组件向子组件通信：通过props参数传递。
子组件向父组件通信：通过props+回调函数。
跨级组件的通信方式：1、利用第三方组件库，如mobx。2、利用Context。3、利用自定义事件通信。
```

#### 路由

##### 1、React-Router的实现原理是什么？

```javascript
同Vue-Router。
```

##### 2、React-Router的路由有几种模式？

```javascript
broswerHistory、hashHistory。
```

##### 3、React-Router如何获取参数？

```javascript
1、get传值。通过正则去解析url里面的参数。
2、动态路由传值。可以通过match.参数名或hook useParam获取。
3、query或state传值。location.state 或location.query 获取。但是存在缺点就是只要刷新页面，参数就会丢失。
```

##### 4、React-Router在怎样在路由变化时重新渲染同一个组件。

```
监听componentWillReceiveProps生命周期。
```

##### 5、如何配置 React-Router 实现路由切换？

```react
1、使用<Route> 组件。路由匹配是通过比较 <Route> 的 path 属性和当前地址的 pathname 来实现的。当一个 <Route> 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 <Route> 将始终被匹配，可以通过设置exact实现精确匹配。
2、结合使用 <Switch> 组件和 <Route> 组件。<Switch> 不是分组 <Route> 所必须的，但他通常很有用。 一个 <Switch> 会遍历其所有的子 <Route>元素，并仅渲染与当前地址匹配的第一个元素。
3、可以通过Redirect设置路由重定向。

<Switch>
    <Route exact path="/" component={Home} />
    <Route path="/about" component={About} />
    <Route path="/contact" component={Contact} />
</Switch>
    
 tips: 可以通过withRouter 提供了history里面push、go等方法进行路由跳转。也可以通过Link跳转。
```

##### 6、react-router 里的 Link 标签和 a 标签的区别？

```javascript
从最终渲染的 DOM 来看，这两者都是链接，都是 标签<Link>是react-router 里实现路由跳转的链接，一般配合<Route> 使用，使用该方式跳转，对应的Route会更新，而不是刷新整个页面。
1、如果有onclick事件就执行该事件。
2、click时候阻止了a标签默认的事件。
3、根据to跳转至对应的Route，不会刷新整个页面。
```

#### Hooks

##### 1、React Hook实现原理是什么？

```javascript
当函数组件第一次渲染执行上下文时，每个react hooks执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上，然后react hooks的状态，绑定在当前hooks对象的memoizedState属性上。对于effect副作用钩子，会绑定在workInProgress.updateQueue(保存待更新队列)上，等到commit阶段，dom构建完成，在执行每个effect副作用钩子。
tips:hooks 主要属性
hooks = {
	baseState,//初始值,
	memoizedState,//hook state信息
	updateQueue,//待更新队列
	baseQueue,//最新更新队列
	next,//链表指针
}
```

##### 2、为什么useState要使用数组而不是对象？

```javascript
如果返回的是对象，结构时必须要和useState内部实现返回的名称同名，想要使用多次，必须设置别名。返回数组则不会有这样的问题。
```

##### 3、React Hooks优缺点是什么？

```javascript
优点
1、能够从组件中提取状态逻辑和将组件拆分成更小的颗粒度，使得这些逻辑可以单独测试复用。
2、类组件语法有些冗余，且需要理解this指向问题。Hooks结合函数式组件使得语法更加简洁明了。
缺点
1、调用时序。useState声明必须按照一定的顺序来的，不能声明在循环、条件、嵌套函数中，因为hooks数据结构存储是按照链表的方式来存储的且是通过useState调用顺序来确定下一次渲染的state，如果声明在条件语句中，会造成顺序错乱，导致获取数据不正确。
2、useRef保留的引用始终不会改变，是用闭包方式来实现，过多使用或者滥用会导致内存泄漏。
3、设计混乱的useEffect。参数deps(依赖项)只要其中一个值发生变化，useEffect里面方法就会重新执行，这种情况，我们其实只需要改变值后对应的方法执行，而不是所有的方法都会执行，会造成心智负担，对新手不是很友好。
4、必须始终在 React函数的顶层使用Hook。
```

##### 4、useEffect 与 useLayoutEffect的区别。

```javascript
共同点：用来处理副作用。包括数据的请求，事件订阅，DOM操作等。
不同点：
useLayoutEffect 是在所有DOM变更之后会同步调用，主要用来操作DOM(先改变DOM后渲染)，且不会造成页面闪烁。useEffect是异步调用的，当用来操作DOM时，可能会造成屏幕闪烁(先渲染，在改变DOM)。
```

##### 5、为什么不能在条件语句中调用 Hook 呢？

```javascript
hook数据结构存储是采用链表来存储。所以hook必须要按照声明要必须要保证顺序。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，造成难以预料的错误。
```

##### 6、useEffect 依赖为空数组与 componentDidMount 区别。

```javascript
componentDidMount：在render之后，componentDidMount会执行，在该生命周期中，执行setState方法，会再次导致render，返回新的值，但是浏览器只会渲染第二次render返回的值，这样避免了闪屏。
useEffect：是在真实的DOM渲染后在执行的，会造成两次render，有可能会闪屏。useLayoutEffect更接近于componentDidMount。
```

##### 7、React.memo 和 React.useMemo、React.useCallback的区别。

```javascript
React.memo： 是一个高阶组件，默认情况下会对prop进行浅比较，如果不相等则重新渲染。
React.useMemo： 返回的是一个缓存值，只有依赖发生变化时才会重新执行。useMemo 是在 render 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作。
React.useCallback： 缓存函数，避免每次渲染后都会重新执行一个新的函数。如果uesEffect中依赖的函数，没有使用useCallback缓存起来，那么每次重新渲染，该依赖的函数都会重新生成，即引用地址发生了变化，会造成useEffect再次执行。
```

##### 8、调用三次setAge函数，如setAge(age + 1)输出结果是什么？

```
age 将只会变为 43 而不是 45！这是因为调用 set 函数 不会更新 已经运行代码中的 age 状态变量。因此，每个 setAge(age + 1) 调用变成了 setAge(43)。为了解决这个问题，你可以向 setAge 传递一个 更新函数setAge(a => a + 1)。a => a + 1 是更新函数，它获取待定状态并从中计算 下一个状态。
```

#### 虚拟DOM

##### 1、React diff算法原理是什么？

```javascript
Diff算法通过比较新旧树的差异，将更新的补丁作用于真实的DOM。React diff 从三个策略进行复杂度的优化。
基于树组件对比：忽略节点跨层级操作场景。对比同一层级节点，如果发现该节点不存在，那么就会直接删除该节点，而不用继续去比较其子节点。
基于组件对比：如果组件类型一致，则默认相似结构。反之，则为不同的结构。如果组件是同一类型，就会进行对比，如果不是则放入补丁中。
基于节点对比：同一层级的子节点，可以通过key的方式进行列表对比。元素对比发生在同层级中，通过标记节点的方式操作补丁。节点的操作包括插入、移动、删除等。而React可以标记key来追踪被修改的元素，直接对这些元素进行操作，需要遍历递归，从而比较提高效率。
```

##### 2、React key 是干嘛用的？

```javascript
key的作用就是用来追踪哪些元素被修改、删除、移动等。在比较新旧树差异时，无需递归比较整棵树，只需要比较被标记元素即可，提高效率。
```

##### 3、React 与Vue的diff算法有何不同？

```javascript
相同点：
1、不做跨层级节点比较
2、通过key提升diff效率
不同点：
1、Vue使用双向指针，边比较边更新DOM。React则比较新旧树差异，得到patch树，然后统一更新DOM。
2、Vue对比节点是，当节点类型相同时，如果className不同，则认为是不同的元素类型，删除重新创建。而React则认为是同类型节点，进行修改操作。
```

#### 其他

##### 1、React状态提升是什么？使用场景有哪些？

```javascript
多个组件需要共享的状态提升到它们最近的父组件上，然后由父组件通过属性的形式分发给各个子组件。
```

##### 2、为什么React要用JSX，不用template？

```javascript
JSX是JavaScript的语法扩展。一种类似于XML的数据结构。XML在数据结构描述更具有可读性。且JSX语法可以使用完整的JS语法来构建页面。比如可以使用临时变量、条件控制语句等。
template在代码结构更符合视图与逻辑分离的习惯，更简单、更直观。
```

##### 3、React设计思路，它的理念是什么？

```javascript
1、简化可复用的组件
2、Virtual DOM
3、函数式编程
```

##### 4、useState更新相同的State,函数组件执行2次？

```javascript
函数组件渲染是通过workInProgress内存树和current渲树来实现的。两棵树之间通过alternate属性关联起来的。
当第一次渲染时，树A不存在alternate属性，所以就将树A直接复制一份当做workInProgress称为树B。所有的操作都在树B中进行，当state值更新后，以树B渲染。渲染完成后。树A和树B通过alertnate互相指向。此时树B作为下一次current树。
第二次调用是，current树的值已经是更新后的值，而workInProgress内存树还是初始值，两棵树的baseState不一致，因此组件就会重新渲染一次。
```

##### 5、React中props.children和React.Children的区别。

```javascript
props.children:通过该属性父组件可将其所有子组件都显示出来。
React.Children： 通过该方法可以获取父组件下的子组件集合，可以通过React.Children.map 和React.cloneElement 为每个子组件传递参数和设置属性。

tips:JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。
```

##### 6、React开启严格模式(`StrictMode`)有哪些好处。

```
1、组件将重新渲染一次，以查找由于非纯渲染而引起的错误。
2、组件将重新运行 Effect 一次，以查找由于缺少 Effect 清理而引起的错误。
3、组件将被检查是否使用了已弃用的 API。
```

### 计算机网络

------

#### HTTP协议

##### 1、GET和POST的请求区别。

```javascript
是否有缓存：浏览器一般会url进行缓存。但很少会对post请求缓存。
安全性质：get请求会将参数放在url中，这样url请求会被浏览器记录。
请求长度：浏览器对get请求的长度有限制。
参数形式：get请求是将参数放在url后面。post请求则是将参数放在请求的报文中。
TCP数据包：get请求会产生一个tcp数据包，发送请求时将header和data一起发送。
		 post请求则会产生两个tcp数据包，第一次先发送header信息，服务器响应100 continue，然后再次发送请求数据,服务器响应200 OK（返回数据）。 	
```

##### 2、HTTP请求报文和响应报文组成部分。

```javascript
请求报文：
1、请求头。包括请求方法、url地址、协议版本等。
2、请求行。包括Host字段、Cookie、自定义header信息等。
3、请求体。post、put请求参数数据。
响应报文：
1、响应头。包括协议版本、请求状态码等。
2、响应行。包括响应数据类型(content-type)、是否缓存、消息发送时间等字段。
3、响应体。服务器返回的数据。
```

##### 3、HTTP1.0和HTTP2.0的区别。

```javascript
相对于HTTP1.0，HTTP2.0有以下好处。
1、多路复用。一次连接，多个请求并用，解决了队首阻塞的问题(HTTP1.0发送消息是串行，采用先进先出的方式。当第一个请求阻塞时，就会影响到后面的请求)。
2、请求优先级。
3、服务器推送。允许服务器主动向客户端发送消息。
4、头部信息压缩。HTTP1.0每次请求都会携带大量的头部信息，这些头部信息有很多重复字段，这样就占用了网络资源。HTTP2.0采用HPACK压缩方式，将头部信息压缩后在此发送(维护一张数据表，用索引表示重读的字段，然后对齐进行压缩和编码)。
5、二进制分帧层。HTTP1.0采用的是文本传输的方式。HTTP2.0则是采用数据分帧的方式，将数据拆分成多个数据帧发送，接收到数据拼成完整的消息。
```

##### 4、HTTP请求的三次握手和四次挥手。

```javascript
三次握手
1、客户端向服务端发起连接请求。
2、服务端收到请求后，向客户端做出应答。
3、客户端收到服务器端的应答后，会向服务器发送一个确认报文，服务器收到这个确认报文后，建立连接。
四次挥手
1、客户端发服务器端发送释放请求。
2、服务器收到请求，做出应答，此时服务器数据可能还没有发送完成。
3、服务器发送数据完成后，发送释放连接请求。
4、客户端收到请求后，发送答应。若该段时间内没有服务器重新请求，那么客户端就进入关闭状态了。服务器收到答应后也进入关闭状态了。

tips:为什么要进行三次握手？
为了确认双方接收能力和发送能力是否正常。如果是两次，则有可能造成网络资源的浪费和传输数据缺失。

tips：为什么要进行四次握手？
因为TCP的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。
```

##### 5、浏览器输入一个网址后发生了什么？

```javascript
1、解析url。解析url是否正确合法。
2、判断缓存。判断请求资源是否有缓存，如果有缓存且未失效，就直接使用。否则就发起请求。
3、DNS解析。通过DNS协议解析url来获取对应的IP地址。详情见DNS查询过程。
4、获取MAC地址。获取IP地址，需要通过IP地址来去本机的MAC地址，数据传输需要MAC地址和端口号。
5、三次握手。
6、返回数据。当页面收到请求后，会返回一个html文件作为响应内容。浏览器收到响应内容，就会开始渲染页面了。
7、渲染页面。
	1、解析DOM节点，生成DOM树。
	2、解析css文件，生成CSS规则树。
	3、将DOM树和CSS树组合成渲染树。渲染树包括DOM的位置信息和其他属性信息。
	4、浏览器生成渲染树完后，会根据渲染树的位置信息进行布局。
	5、布局完成后，使用浏览器的UI接口对其进行绘制。等待绘制完成后，浏览器就能显示页面了。
8、四次挥手。
```

##### 6、HTTP协议的优缺点。

```javascript
优点：
1、支持客户端/服务器模式。
2、简单快速。客户端想服务器请求时，只需要传递请求方式和请求地址即可。
3、灵活。HTTP可以传输任意数据类型的数据。
缺点：
1、无状态。无法记住通信过程中的上下文信息。
2、明文传输。协议中使用的是文本形式传输，这样可能就能被别人截取信息，不安全。
```

##### 7、URL有哪些组成部分。

```javascript
1、协议部分。比如HTTP、HTTPS等。
2、域名部分。紧跟协议部分后面的字符串。
3、端口部分。
4、路径名称。从第一个'/'到最后一个'/'之间的名称。
5、锚部分。'#'后面的部分。
6、参数部分。'?'之后的部分。参数之间用&连接。
```

##### 8、HTTP协议的特征。

```javascript
管道化。请求按照先进先出的队列方式。
无状态。HTTP是一种无状态的协议的。
持久连接。通信两端如果一方没有提出断开连接，就保持连接。以便下次连接，避免造成连接和断开的开销。
```

##### 9、常见的HTTP请求头和响应头。

```javascript
HTTP Request Header 常见的请求头：
Accept：浏览器能处理的内容类型。
Accept-Charset：浏览器显示的字符集。
Accept-Encoding：浏览器处理的编码。
Accpet-Language：浏览器当前设置的语言。
Cookie：当前页面设置的Cookie。
Host：发送请求所在域。
Referer：发送请求的Url。
User-Agent：浏览器代理信息。

HTTP Responses Header 常见的响应头：
Date：服务器发送消息时间。
server：服务器名称。
Cache-Control：控制HTTP换粗。
Content-Type：文档MIME类型。

常见的Content-Type属性
1、application/x-www-form-urlencode：原生form表单提enctype属性默认值，提交数据会以key&value的方式提交。
2、application/json：服务器消息返回数据是序列化的JSON串。
3、multipart/form-data：上传文件通常采用该方式。
4、text/xml：提交xml数据。
```

##### 10、常见的HTTP请求方法。

```
GET：向服务器获取数据。
POST：将实体提交到指定资源位置，会造成资源的修改。
PUT：更新数据。
DELETE：删除数据。
HEAD：获取报文首部，与GET相比，不会报文主体。
OPTIONS：询问请求所支持方法，常用于跨域请求。
```

##### 11、对keep-alive的理解？

```javascript
HTTP1.0中默认每次发送请求/答应，客户端与服务端都会建立连接，完成之后就会断开连接，这就是短连接。当使用keep-alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，避免了建立或重新连接。这就是长连接。
HTTP1.0中默认是没有开启该功能的，使用时需要手动配置Connection：keep-alive字段，关闭是需要配置Connection：close字段。但是，若是长时间的TCP连接容易导致系统占用资源无效，浪费系统资源。
```

##### 12、页面有多张图片，HTTP是怎样的加载表现？

```javascript
1、HTTP1.0中浏览器对同一域名下最大TCP连接数为6，所以或多次请求。
2、HTTP2.0中，可以同时加载多张图片资源，因为HTTP2.0支持多路复用，可以在一个TCP连接中发送多个HTTP请求。
```

##### 13、HTTP2的头部压缩算法？

```javascript
HTTP2采用的是HPACK算法。在客户端服务端建立"字典"，用索引号表示重复字典来压缩整数和字符串，来提升效率。(webpack生成sourceMap文件也是采用类似的压缩方式)。
1、在客户端与服务端使用"首部表"来跟踪和存储之前发送的键值对，对于相同的数据，不在通过每次请求和响应发送。
2、每个新的首部键值对要么被追加到字典末尾，要么替换表中之前的值。
```

##### 14、与缓存相关的HTTP请求头有哪些？

```javascript
强缓存
1、Expires
2、Cache-Control
协商缓存
1、Etag、If-None-Match
2、Last-Modified、If-Modified-Since
```

##### 15、 HTTP 1.0 和 HTTP 1.1 之间有哪些区别？

```javascript
1、连接方面。http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接(keep-alive)。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
2、资源请求方面。http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分。
3、http1.1 中新增了 host 字段，用来指定服务器的域名。
4、缓存方面。http1.1 则引入了更多的缓存控制策略，如Etag、If-Match等。
5、http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。
```

##### 16、HTTP和HTTPS协议的区别？

```javascript
HTTP和HTTPS协议的主要区别如下
1、HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的TLS/SSL加密传输协议，相对于HTTP更安全。
2、使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443。
```

##### HTTPS协议

##### 1、HTTPS如何保证安全的？

```javascript
HTTPS通过TLS/SSL来数据进行加密。主要采用散列函数hash、对称加密、非对称加密、数字证书这几种加密方式。

散列函数hash：常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，输出长度固定。
对称加密：双方都使用同一个秘钥进行加解密。秘钥通过网络传输有可能会被别人获取。
非对称加密：拥有两个秘钥。一个公钥、一个私钥。当我们采用私钥加密时，只有公钥才能解密。使用公钥加密时，只有私钥才能解密。在使用时只需要将公钥发布出去即可。该加密算法计算复杂，且加密速度慢。
数字证书：对称/非对称加密。秘钥是通过网络传输，都有可能被劫持的风险。数数字证书相对于这两种加密方式更安全，但是费用高。客户端发起HTTPS请求时，服务器会返回一个公钥证书，使用公钥对数据进行加密后在发送。
```

#### DNS

##### 1、DNS完整查询过程。

```javascript
1、在浏览器缓存中查询对应IP地址，找到则返回，否则进行下一步。
2、在本地DNS服务器中查找。找到则返回，否则进行下一步。
3、在根域名中查找。
4、在顶级域名中查找。
5、在权威域名中查找。
6、如果在上述过程中，找到对应IP，会将结果保存在缓存中并返回给浏览器。找不到就报错。
```

#### 网络模型

##### 1、OSI七层模型。

```javascript
1、应用层。为程序提供各种服务。
2、会话层。建立管理维护会话。
3、表示层。用来处理数据的操作。
4、网络层。IP地址及路由选择。IP协议属于这一层。
5、传输层。建立、管理端与端之间的连接。TCP和UDP属于一层。
6、数据链路层。提供访问介质。
7、物理层。提供物理访问介质。
```

##### 2、TCP/IP五层协议。

```javascript
1、应用层
2、网络层
3、传输层
4、物理层
5、数据链路层
```

#### TCP和UDP

##### 1、TCP和UDP的区别。

```javascript
1、TCP面向连接。UDP则无连接，只管发送数据，不管数据是否发送成功，因此UDP连接不可靠。
2、TCP只能支持一对一连接。UDP支持一对一、一对多、多对多连接。
3、TCP主要用于效率相对较低，但是准确性较高的场景。如文件传输，数据更新等。
4、UDP主要用效率较高，准确性较低的场景。如即时通话等。
tips：因为TCP要进行三次握手和四次挥手，因此TCP效率要比UDP低。
```

##### 2、UDP协议为什么不可靠？

```javascript
UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。
1、不保证消息交付：不确认、不重传、无超时。
2、不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞。
3、不跟踪连接状态：不必建立连接或重启状态机。
4、不进行拥塞控制：不内置客户端或网络反馈机制。
```

#### Websocket

##### 1、对websocket的理解。

```javascript
websocket 是HTML5提供的一种浏览器与服务器全双工(双向同时)通信方式，属于应用层协议。它基于TCP传输协议，浏览器与服务器只需要一次握手，就能建立持久性连接，并进行双方数据通信。其特点是客户端能够向服务器推送消息，服务端也能向客户端推送消息。主要有以下几个事件和方法。
1、onmessage。监听收到数据触发事件。
2、onclse。关闭连接触发事件。
3、send。发送消息方法。
4、onopen。打开连接触发事件。
```

##### 2、短轮询、长轮询以及websocket的区别。

```javascript
短轮询：浏览器每隔一段时间就想服务器发送一次消息，服务器收到消息后，无论是否数据有更新，都会做出响应。这样会造成服务器压力大。
长轮询：客户端向服务端发起请求，建立请求后，服务器不会立即响应这个请求，而是会将这个请求挂起，不会断开请求，等到有数据更新或者达到一定时间后，服务器才会做出响应。当客户端收到响应时，处理完数据后，会重新发次请求。挂起过程，也会造成资源的浪费。
websocket：全双工通信，支持服务端与客户端双向通信。缺点就是服务器端配置较复杂。
```

### 浏览器原理

------

#### 浏览器安全

##### 1、XSS和CRSF是什么？怎样防御。

```javascript
XSS是一种跨站脚本攻击，是一种脚本注入工。通过在网站上，注入脚本，从而盗取用户cookie等信息。其本质就是网站是没有对恶意的代码进行过滤，导致恶意代码与正常代码一起运行。
XSS防御：
1、使用纯前端的方式，不使用服务端拼接返回内容的方式。
2、通过对恶意代码进行过滤，即对插入HTML的代码进行充分的转义和过滤。
CRSF是一种跨域请求伪造攻击。本质上就是利用cookie在同源请求会携带并发送给服务器的特点，利用这一点就可以实现跨域请求伪造攻击。可以通过以下方式来防止该攻击。
1、cookie同源。通过判断HTTP请求中的refer或origin的信息来判断是否允许访问。
2、利用token验证。服务器会向用户返回一个token令牌，每次发起请求，都会携带这个token，然后服务器对这个token进行验证是否正确。
3、在设置cookie时设置same site，限制cookie被第三方使用。
```

#### 进程和线程

##### 1、进程和线程的区别。

```javascript
进程：资源分配的最小单位。启动一个程序时，操作系统就会为该程序创建一块内存，用来存放代码、运行中的数据和一个运行任务执行的主线程等，我们称这样的运行环境为进程。
线程：CPU调度的最小单位。
进程与线程有以下的特点：
1、进程中任意一线程出错，会导致程序报错
2、进程之间的内容互不干扰
3、当进程关闭时，操作系统会回收进程所占用的内存
4、线程之间数据共享
```

##### 2、谷歌浏览器常用浏览器进程有哪些？

```javascript
1、浏览器主进程。主要用来显示页面、用户交互等功能。
2、GPU进程。浏览器UI界面绘制。比如Css动画效果和3D会开启GPU加速。
3、渲染进程。将HTML、Css、JavaScript转化成与用户交互的网页。
4、网络进程。主要负责页面网络资源的加载。
5、插件进程。主要是负责插件的运行。
```

#### 浏览器缓存

##### 1、对浏览器的缓存机制的理解。

```javascript
首先判断是否命中强制缓存，没有命中就进行协议缓存。如果两种缓存都没有命中，那么就是启发式缓存。
强制缓存
	1、如果cache-control：no-cache，那么就是无强制缓存，直接进入协议缓存阶段。
	2、如果cache-control：max-age=xxx,就会比较当前时间与上一次请求成功的时间差，是否小于max-gae，如果小于max-age，就读取缓存内容。
	3、强制缓存会触发from disk cache(样式、脚本、图片等) 硬盘缓存和from memory cache(大文件等) 内存缓存，优先会从内存中读取缓存，然后再是硬盘缓存。
协议缓存:协议缓存中有两个重要的属性，一个是If-Modifed-Since，另外一个是If-None-Match。If-Modifed-Since比较的是服务器时间，而If-None-Match比较的是ETag(服务器会为每个资源文件生成一个唯一的标志)。如果命中缓存则返回304。不一致则返回新的Last-Modified时间或文件并返回200。
启发式缓存:如果没有设置任何缓存策略，就会启用该缓存，通常会根据响应头中的两个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。
```

##### 2、浏览器资源缓存的位置有哪些。

```javascript
Service Worker：离线缓存。
Memory Cache：内存缓存，它的效率最快。读取高效，缓存时间短。一旦关闭tab页签，缓存就被释放了。
Disk Cache：储在硬盘中的缓存，读取速度慢点。读取效率低，但是缓存时间长。
```

##### 3、三种刷新操作对 http 缓存的影响。

```javascript
正常操作：输入url跳转等。强缓存、协商缓存都不会失效。
手动刷新：F5，手动刷新等。强缓存失效、协商缓存不会失效。
强制刷新：ctrl+F5刷新。强缓存失效和协商缓存都会失效。
```

#### 浏览器渲原理

##### 1、浏览器渲染过程。

```javascript
1、解析DOM节点，生成DOM树。
2、解析css文件，生成CSS规则树。
3、将DOM树和CSS树组合成渲染树。渲染树包括DOM的位置信息和其他属性信息。
4、浏览器生成渲染树完后，会根据渲染树的位置信息进行布局。
5、布局完成后，使用浏览器的UI接口对其进行绘制。等待绘制完成后，浏览器就能显示页面了。
```

##### 2、渲染过程中遇到JS文件如何处理。

```javascript
JavaScript的加载、解析、执行会阻塞文档的解析。在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。因此应该将JS文件放在body后面，等待DOM解析完成，再去解析和执行JS文件。
```

##### 3、CSS 如何阻塞文档解析？

```javascript
JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSS 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSS 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSS，然后再执行 JavaScript，最后再继续文档的解析。
```

#### 浏览器同源策略

##### 1、是什么同源策略。

```javascript
同源策略就是协议、域名、端口一致。同源策略目的是主要为了保护用户信息安全。跨域请求就是同源策略引起的。它只是一种对js脚本的限制，并不是对浏览器。对于一般的img或者脚本不会有限制。
```

##### 2、如何解决跨域问题。

```javascript
1、CROS。通过服务器端设置Allow-Origin、Allow-Methods、Allow-Headers来实现跨域请求。
2、JSOP。利用<script>标签没有跨域限制，通过src属性发送带callback请求来实现跨域。
3、postMessage跨域。通过iframe的postMessage方法以及监听message事件来实现跨域。
4、nginx代理跨域。实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段来实现跨域。
```

#### 浏览器本地存储

##### 1、cookie、localStorage、sessionStorage的区别。

```javascript
cookie：cookie数据始终在同源的http请求中携带（即使不需要），可以设置过期时间和在哪个路径下cookie生效，大小为4k。在cookie有效期间，关闭浏览器和窗口，cookie不会被销毁。
session:session是存储在服务器端。相对于cookie更安全，存储数据类型和数据大小也比cookie更加有利，但是当客户端关闭的时候，session会失效。
localStorage：请求不会在同源http中携带。大小为5M或更多。localStorage存储在本地硬盘中，因此用作持久数据，在所有同源窗口中数据共享，可以通过监听storage事件来实现标签页的实时通信。
sessionStorage：和localStorage类似。但是当浏览器关闭和窗口关闭时。sessionStorage会自动销毁。不在不同的浏览器窗口中共享，即使是同一个页面。但是在某些特定的场景下，在该标签页或窗口打开一个新的页面会复制顶级浏览器的上下文作为新会话的上下文(window.open或a标签打开)，不同窗口之间的状态会共享。
```

#### 浏览器事件机制

##### 1、JavaScript事件模型？

```javascript
事件模型分为事件捕获和事件冒泡。事件触发分三个阶段。
1、从window往事件触发处传播，遇到注册的捕获事件会触发。
2、到达事件捕获目标元素处。
3、从事件触发处往 window 传播，遇到注册的冒泡事件会触发。
```

##### 2、对事件循序的理解。

```javascript
1、JS的单线程任务被分成同步任务和异步任务。同步任务在主线程中执行，而异步任务在被加入到一个消息队列中。
2、当同步任务执行完成后，就开始读取消息队列中的任务，并推入主线程开始执行。而异步任务又分为宏任务和微任务
3、当开始执行异步任务时，首先从宏任务开始执行，当队列里面宏任务执行完成后，就开始执行微任务，并将所有微任务执行完成。开始读取下一个宏任务。
4、不停重复宏任务与微任务的执行过程，直到所有任务执行完成。

根据W3C最新标准，每个任务有不同的类型，同类型的任务必须在一个队列中，不同的任务属于不同的队列，任务队列有不同的优先级，在一次事件循环中，有浏览器决定取哪一个队列的任务，但是浏览器必须有一个微队列，微队列的任务具有最高优先级，必须优先调度执行。Chrome浏览器中，至少包含以下队列
1、延时队列。用于存放计时器到达后的回调任务。(优先级中)
2、交互队列。用于存放用户操作后产生的事件处理任务。(优先级高)
3、微队列。用户存放需要最快执行的任务。(优先级最高)
tips：
宏任务：setTimeout等。
微任务：Promise、MutationObserve等。
```

##### 3、哪些操作会造成内存泄漏？

```javascript
1、使用为声明的变量，会被提升为全局变量，导致变量无法回收
2、使用setInterval 定时器，忘记取消定时器。
3、过度的使用闭包，导致变量一直存在内存中。
```

##### 4、如何理解JS的异步？

```
JS是一门单线程的语法，这是因为它运行在浏览器的渲染主线程中，而渲染主线程中只有一个，渲染主线程执行诸多工作，如渲染页面、执行JS等。如果使用同步的方式，就极有可能导致主线程阻塞，从而导致消息队列中任务无法执行，这样就会造成性能消耗和用户的操作无法得到响应造成极差的体验。于是浏览器则采用异步的方式来避免，当直线某些任务时，比如计时器，网络、时间监听等，主线程将任务交给其他线程去处理，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队。等到自身任务执行完成，就会开始执行后续代码。
```

##### 5、JS中的计时器能做到精确计时吗？

```javascript
1、计算机硬件没有原子钟，无法做到精确计时
2、受事件循环的影响，计时器函数调用只能在主线程空闲的时候运行，因此会造成偏差。
```

### 前端工程化

------

##### 1、开发一个脚手架的流程。

```javascript
脚手架主要作用是通过将远端的初始化项目模板拉取至本地中，可以用过参数配置来定项目所需功能，主要分为以下几个步骤。
1、新建一个bin目录，然后创建对应的命令文件。
2、引用commander第三方库，自定义命令。
3、在pagejson文件，新增bin属性，在bin属性下面新增，自定义命令，需要与commander定义的命令保持一致，这是命令的入口地址。
4、完成每个命令完成对应的功能即可。
5、可以使用npm link在命令全局挂载来测试功能是否正常。

采用的第三方库
1、inquiry。交互式命令行工具。
2、commander 用来编写指令和处理命令行。
3、download-git-repo 用来下载远程模板的，支持 GitHub、 GitLab 和 Bitbucket等。
```

##### 2、常见的Loader和Plugin。

```javascript
Loader
1、file-loader。处理图片和字体资源文件。
2、ts-loader。ts转化成js。
3、babel-loader。将ES6转化成ES5，以及转化JSX。
4、css-loader。加载css，支持压缩、模块化等功能。
5、sass-loader。将sass样式转化成css样式。
6、vue-loader。将vue转化成js。
Plugin
1、define-plugin。用来定义环境变量。
2、html-webpack-plugin。创建HTML文件以及其依赖。
3、mini-css-extract-plugin。分离样式文件。支持css文件提取。
4、clean-webpack-plugin。清除目录文件。
5、copy-webpack-plugin。复制文件或目录到执行区域，如vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist 文件夹中。
```

##### 3、Loader和Plugin的区别。

```javascript
Loader本质上是一个函数，用来转化Webpack无法识别的文件类型，因为webpack只能识别js。通过在module.rules 中配置，类型为数组。Loader可以分为四类，其对应的优先级pre(前置) > normal（普通） > inline（内联） > post（后置）。Loader执行顺序是从右到左，从下到上，采用compose函数组合的方式。
Plugin是webpack插件。在webpack运行过程中会广播出许多生命周期，plugin则是通过监听这些生命周期来实现对打包结果的改变。在Plugin中配置，每一项都是一个plugin实例，参数通过构造函数传入。
```

##### 4、Webpack构建流程。

```javascript
初始化参数：获取配置文件和命令参数文件，并将其合并。
开始编译：通过参数实例化Complier对象，加载所有插件的配置，开始编译。
确定入口文件：根据配置文件的entry确定入口。
编译模块：从入口文件出发，调用配置的Loader对模块及其依赖模块进行遍历递归翻译。
完成模块编译：得到每个模块被翻译后之间的依赖关系。
输出文件：根据入口和模块之间的依赖关系，生成一个或多个bundle.js，根据配置文件的输出的路径和文件名，将其内容写入到文件系统中。

// webpack 打包过后的代码
(function(modules) {
  // 已经加载过的模块
  var installedModules = {};
  // 模块加载函数
  function __webpack_require__(moduleId) {
    if(installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  __webpack_require__(0);
})([
/* 0 module */
(function(module, exports, __webpack_require__) {
  ...
}),
/* n module */
(function(module, exports, __webpack_require__) {
  ...
})])；

1、经过webpack打包出来的是一个匿名闭包函数（IIFE）
2、modules是一个数组，每一项是一个模块初始化函数
3、__webpack_require__用来加载模块，返回module.exports
4、通过WEBPACK_REQUIRE_METHOD(0)启动程序
```

##### 5、文件监听原理。

```javascript
在文件源码发生变化时，自动构建。可以通过命令--watch或者配置watch：true开启该功能。这是通过轮询判断文件的最后编辑时间是否发生改变，如果某个文件发生变化，并不会立即告诉监听者，而是将其缓存起来，等到合适的时间才会去执行。这种文件监听不会触发浏览器自动刷新，每次构建完成都需要收到刷新浏览器才能看到构建后的内容。
```

##### 6、webpack热更新原理。

```javascript
1、通过 webpack-dev-server 创建两个服务器: 提供静态资源的服务 (express) 和Socket服务。
2、express server 负责直接提供静态资源的服务(打包后的资源直接被浏览器请求和解析)。
3、socket server 是一个 websocket 的长连接，双方可以通信
4、当 socket server 监听到对应的模块发生变化时，会生成两个文件,json (manifest文件)和js文件。
5、通过长连接，socket server 可以直接将这两个文件主动发送给客户端 (浏览器)。
6、浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新。

热更新涉及到几个模块：
1、Bundle Server。提供网页访问服务
2、HMR Sever。将热更新的文件输送给HMR runtime。(知道哪些资源文件发生了变化)
3、HRM runtime。在构建阶段，会被注入到bundle.js 里面。(接受差异文件，并更新代码)
4、bundle.js。 构建最终输出文件
```

##### 7、webpack proxy工作原理？为什么能解决跨域？

```js
proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发。
在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。

注意:服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制
```

##### 7、文件指纹是什么？

```javascript
文件指纹是打包后输出的文件名的后缀。
Hash：整个项目文件有关。只要有项目文件发生变化，该值就会发生变化。
ContentHash：根据文件内容来决定该值是否发生变化。
ChunkHash：Chunk发生变化时，该值发生变化。
```

##### 8、如何优化Webpack 性能？

```javascript
1、优化Loader。设置优化Loader的文件搜索范围，来减少搜索文件范围（搜索范围越大，转换代码越多，效率越低）和设置缓存。
2、HappyPack。HappyPack 可以将 Loader 的同步执行转换为并行的，实现多线程打包。
3、动态分离库。将不需要修改的npm包来进行预编译，然后再加载进来。
4、代码压缩。删除多余的代码、注释、简化代码的写法等等⽅式。
5、按需加载。可以使用按需加载，将每个路由页面单独打包为一个文件。
6、Scope Hoisting。Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。
7、Tree Shaking。Tree Shaking 可以实现删除项目中未被引用的代码。
8、多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码。
9、利⽤CDN加速。在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。
10、提取公共第三⽅库。提供公共第三库，利用浏览器缓存这些无需频繁变动的代码。
```

##### 9、如何编写Loader以及其原理。

```javascript
Loader充当webpack"翻译"的角色，其实就是将内容转化后输出给下一个函数。因此开发上需要严格遵循"单一职责"，每个 Loader只负责自己需要负责的事情。每个Loader拿到的是源文件的内容，可以通过返回值的方式将处理后的内容输出，可以调用this.callback()使用同步方法将内容返回给webpack，也可以调用this.async()异步方法得到一个callback回调函数，利用这个回调函数将处理好的内容输出出去。由于同步计算过于耗时，在 Node.js 这样的单线程环境下进行此操作并不是好的方案，建议尽可能地使loader 异步化。但如果计算量很小，同步 loader 也是可以的。

/*
* content 处理后的内容
* source-map 继续传递source-map
* meta 给下一个loader传递参数
*/
module.exports = function (content, map, meta) {
  /*
    第一个参数：err 代表是否有错误
  */
  // 同步操作
  this.callback(null, content, map, meta);
  // 同步loader中不能进行异步操作
  return; // 当调用 callback() 函数时，总是返回 undefined
  
  // 进行异步操作
  const callback = this.async();
  setTimeout(() => {
    callback(null, result, map, meta);
  }, 1000);
};
```

##### 10、如何编写Plugin。

```javascript
webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。
1、compiler是与Webpack整个生命周期相关的钩子。compilation是每次构建过程中的生命对象，是通过compiler实例化得到的。
2、创建一个插件类，可以通过构造函数来获取外面传递给插件的参数。
3、插件需要在原型上绑定apply方法，才能访问compiler实例。
4、找出合适的事件点完成功能。
5、异步事件调用完成需要调用回调函数(callback)通知webpack进入下一个流程。

class Plugin{
    // plugin参数
    constructor(option){
        this.option = option;
    }
    apply(compiler){
        // 在哪种hooks下触发该事件,详情参考webpack hooks。async表示异步
        compiler.hooks.afterEmit.tapAsync('auto-generate', (compilation, callback) => {
            // 逻辑处理
            callback(null, compilation);
        })
    }
}

module.exports = Plugin;

关于整个编译生命周期钩子：
·entry-option：初始化 option
·run
·compile：真正开始的编译，在创建 compilation 对象之前
·compilation：生成好了compilation 对象
·make 从 entry 开始递归分析依赖，准备对每个模块进行 build
·after-compile：编译 build 过程结束
·emit：在将内存中 assets 内容写到磁盘文件夹之前
·after—emit：在将内存中 assets 内容写到磁盘文件夹之后
·done：完成所有的编译过程
·failed：编译失败的时候
```

##### 11、Babel的原理。

```javascript
Babel 本质是一个转换编译器，简单来说就是将一种编程语言转换成另一种编程语言。
这个转换过程也就是 Babel 的编译过程，可以分为三步:
1、parse 阶段: 通过 parser 将编程语言的源码转换成抽象语法树(AST)。
2、transform 阶段: 遍历 AST，调用 transform 插件对 AST 节点进行增删改等操作。例如函数插桩、删除 console、自动国际化等。
3、generate: 把经过 transform 转换后的 AST 转换为目标代码，并生成 sourcemap。

Babel插件开发
Babel 官方开发了一系列辅助编写插件的包：
1、@babel/parser: 顾名思义，负责 parse 阶段的包，默认只能 parse js 代码，支持扩展，通过指定对应语法插件可实现 jsx、ts 等解析。
2、@babel/traverse: 提供 traverse 方法来负责 AST 的遍历，维护了整颗 AST 树的状态。
3、@babel/generator：负责 generate 阶段的包，用于将 AST 转换成新的代码。
4、@babel/types: 包含所有 AST 节点的类型以及检查 AST 类型的方法。
5、@babel/core: Babel 的核心 api，包含了上述所提的所有功能，能完成从源码到目标代码的整个编译流程。

实现一个箭头转化函数Babel插件伪代码如下：
const t = require("@babel/types");
const ArrowTransformFunctionPlugin = {
  // visitor 接受 path 和 state 参数，path 是 AST 节点树中的路径记录者，也就是说通过各节点的 path，搭建起 AST 树，而且 path.node 属性指向当前节	点；state 则负责 AST 节点间数据传递。
  // @babel/types 中提供了各种 AST 节点类型方法。可访问https://www.babeljs.cn/docs/babel-types查询。
  // 访问属性
  visitor: {
    ArrowFunctionExpression(path, state) {
      const { node } = path;
      const id = node.id;
      const params = node.params;
      const body = t.blockStatement([t.returnStatement(node.body)]);

      const functionExpression = t.functionExpression(id, params, body);
      path.replaceWith(functionExpression);
    },
  },
};
```

##### 12、@babel/runtime和@babel/polyfill的区别。

```javascript
这两个库的作用都是将ES6转化成ES5代码。
@babel/polyfill
1、体积太大。无法做到按需加载。
2、容易污染全局环境。polyfill是通过设置全局对象和内置对象的原型来实现的。如果第三方库也引入了polyfill，并且改写了内对象的原型上的方法，就会导致功能失效。
@babel/runtime 是为编译语法提供的运行环境。它是一个模块且不会污染全局变量和内置对象，需要配合@babel/plugin-transform-runtime一起使用，@babel/plugin-transform-runtime作用是转化代码是提供辅助函数和避免多次编译出helper函数。但是如果是实例上的方法是无法访问的。

tips：
@babel/cli。编译命令用来编译文件或文件夹。
@babel/preset。编译的目标环境。(如es6、es5等)
@babel/polyfill。提供编译器需要的语法环境。babel7已经弃用，采用core-js替代。
@babel/runtime。提供编译器需要的语法环境。一种替代polyfill的方案。需要配合@babel/plugin-transform-runtime一起使用。
@babel/plugin-transform-runtime。提供转化代码的辅助函数和避免多次编译出helper函数。
```

##### 13、pnpm、yarn、npm区别。

```javascript
相比npm，yarn有以下优势。
    1、速度快。
        npm是串行安装，而yarn则是并行安装。
        之前已经安装过的包，yarn是从缓存中获取。
    2、安装依赖统一。每次执行安装命令时，会默认自动生成一个yarn.lock文件用来锁定依赖版本。
    3、更简洁的输出。npm 的输出信息比较冗长。
    4、更好的语义化。yarn命令更加简单明了。
相比npm、yarn，pnpm则具有以下优势:
	1、速度快：多数场景下，安装速度是 npm/yarn 的 2 - 3 倍。
	2、基于内容寻址：硬链接节约磁盘空间，不会重复安装同一个包，对于同一个包的不同版本采取增量写入新文件的策略。
	3、依赖访问安全性强：优化了 node_modules 的扁平结构，提供了限制依赖的非法访问(幽灵依赖)的手段。
	4、支持 monorepo：自身能力就对 monorepo 工程模式提供了有力的支持。在轻量场景下，无需集成 lerna、Turborepo 等工具。
```

##### 14、assets和static的区别。

```javascript
相同点:都是用来存放静态资源文件。
不同点：
assets使用assets下面的资源，在js中使用的话，路径要经过webpack中file-loader编译，路径不能直接写。如果要动态绑定则需要使用require动态导入路径才能生效。static则不会进行处理，直接拷贝至打包好的目录。因此assets主要是用来存放本项目的资源文件，static主要用来存放第三方的资源文件。
```

##### 15、谈谈前端组件库开发。

```javascript
开发一个前端组件应该遵循以下几个原则。
1、设计层次结构和类图(UML)。通过UML可以显示State、Props、Methods和其他组件的依赖关系，相当于组件功能职责的快照，避免出现一些意料之外的事情。比如参数缺失、场景遗漏等。
2、扁平的state和props。尽量不使用嵌套数据，在某些场景中会对性能造成影响，比如因为浅比较而重新渲染。而且扁平化写法更加优雅、明了。
3、开放封闭原则。对不可修改关闭，对可修改开放。
4、辅助代码分离。比如配置代码、假数据等这些辅助性的代码应该抽离出来放在单独的文件。
5、更加纯粹的 State 变化。对 state 的更改通常应该响应某种事件，而不是因为别的state变化而做出反应。

开发组件库辅助工具：
1、docz、vuePress。根据组件生成组件使用文档。
2、verdaccio。搭建组件私有仓库。
3、jest。对组件进行单元测试。
```

##### 16、vite编译原理，对比webpack有哪些优势？

```javascript
一个基于浏览器原生 ES Modules 的开发服务器。利用浏览器去解析模块，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。Vite 要求项目完全由 ES Module 模块组成，commonJs不能直接在vite上使用(浏览器运行的是commonJs)，所以vite打包上还是使用的rollup，虽然原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，即可能造成多次请求(一个文件就是一个请求)，所以出于加载性能考虑，还是选择rollup打包(esbuild对css和代码分割还在持续开发中)。
vite实现主要是通过启动一个 koa 服务器拦截浏览器请求ES Module的请求，对不同的文件类型做出不同的处理，最终以 ES Modules 格式返回给客户端。大致流程如下
1、首先判断请求是否有缓存，Vite利用 HTTP 头来加速整个页面的重新加载，源码模块的请求会进行304 Not Modified协商缓存，依赖文件则是根据ache-Control: max-age=31536000进行强制缓存。如果有缓存则直接读取缓存，否则就进行下一步处理。
2、对于node_modules模块的处理，由于目前不支持裸模块加载，所以需要对模块进行重写，改写成@modules/模块名等方式。
3、当请求的路径符合图片,媒体文件,字体资源文件或JSON格式（通过正则表达式去区分），会被认为是一个静态资源。静态资源将处理成 ES Module 模块返回。
4、对于Vue文件处理，会拆分成template、css、script三个模块进行处理，最后会对 script ,template, css 发送多个请求获取(通过请求地址中的type参数来区分)。对js/ts的处理采用的esbuild构建工具，该工具是用go语言编写，支持多线程，高并发等特性，因此速度会更快。

相对于传统的webpack打包，首先分析文件之间的依赖关系，然后在根据依赖关系将所有的文件打包成一个或多个bundle。随着文件逐渐增多，打包过程耗时也越久。不可避免，当我们只修改了某个模块几行代码，整个bundle.js 都需要重新打包。
vite则完全跳过了这个打包过程，具有冷启动快，即使热更新模块，真正按需编译的特点。
```

##### 17、git和svn的区别?

```
SVN是集中式版本控制系统。版本库是集中放在中央服务器的，首先要从中央服务器哪里得到最新的版本，干完活后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作。
Git是分布式版本控制系统，没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上，然后推送即可。
```

##### 18、Package.json 常用属性以及其作用。

```javascript
描述配置
name：目的名称，如果是第三方包的话，其他人可以通过该名称使用 npm install 进行安装。
version：项目的版本号，开源项目的版本号通常遵循 semver 语义化规范。
1、代表主版本号 Major。通常在涉及重大功能更新，产生了破坏性变更时会更新此版本号
2、代表次版本号 Minor，在引入了新功能，但未产生破坏性变更，依然向下兼容时会更新此版本号。
3、代表修订号 Patch，在修复了一些问题，也未产生破坏性变更时会更新此版本号。
repository：项目的仓库地址以及版本控制信息。
description：项目的描述，会展示在 npm 官网，让别人能快速了解该项目。
keywords：技术关键词。
homepage：项目主页的链接，通常是项目 github 链接，项目官网或文档首页。
bugs：项目 bug 反馈地址，通常是 github issue 页面的链接。
license：项目的开源许可证。
author：项目作者。

文件配置
files：项目在进行 npm 发布时，可以通过 files 指定需要跟随一起发布的内容来控制 npm 包的大小，避免安装时间太长。发布时默认会包括 package.json，license，README 和main 字段里指定的文件。忽略 node_modules，lockfile 等文件。
type：模块规范支持commonjs和module，默认为commonjs。要求 ES 模块采用 .mjs 后缀文件名， CommonJS 脚本的后缀名为.cjs。
main：指定的是项目的入口文件，在 browser 和 Node 环境中都可以使用。如果不设置 main 字段，那么入口文件就是根目录下的 index.js。
browser：如果只想在 web 端使用，不允许在 server 端使用，可以通过 browser 字段指定入口。
module：指定 ES 模块的入口文件。
exports：字段可以配置不同环境对应的模块入口文件，并且当它存在时，它的优先级最高。
"exports": {
  "require": "./index.js",
  "import": "./index.mjs"
 }
}
使用 exports 来封装文件路径,用户引入时只需import `packageA/style`
"exports": {
  "./style": "./dist/css/index.css'
},
workspaces：项目的工作区配置，用于在本地的根目录下管理多个子项目。可以自动地在 npm install 时将 workspaces 下面的包，软链到根目录的 node_modules 中，不用手动执行 npm link 操作。

脚本配置
scripts：指定项目的一些内置脚本命令，这些命令可以通过 npm run 来执行。
config：用于设置 scripts 里的脚本在运行时的参数。

依赖配置
dependencies：项目生产环境下需要用到的依赖。当别人项目需要引用该项目时，才会下载dependencies依赖。如果只是本地开发web项目，dependencies和devDependencies没啥区别。
devDependencies：开发依赖，项目开发环境需要用到而运行时不需要的依赖。
peerDependencies：同伴依赖，一种特殊的依赖，不会被自动安装，通常用于表示与另一个包的依赖与兼容性关系来警示使用者。比如我们安装 A，A 的正常使用依赖 B@2.x 版本，那么 B@2.x 就应该被列在 A 的 peerDependencies 下，表示“如果你使用我，那么你也需要安装 B，并且至少是 2.x 版本”。
optionalDependencies：可选依赖，顾名思义，表示依赖是可选的，它不会阻塞主功能的使用，安装或者引入失败也无妨。
bundleDependencies：打包依赖。它的值是一个数组，在发布包时，bundleDependencies 里面的依赖都会被一起打包。

发布配置
private：如果是私有项目，不希望发布到公共 npm 仓库上，可以将 private 设为 true。
publishConfig：publishConfig 就是 npm 包发布时使用的配置。比如在安装依赖时指定了 registry 为 taobao 镜像源，但发布时希望在公网发布，就可以指定 publishConfig.registry。

系统配置
engines：一些项目由于兼容性问题会对 node 或者包管理器有特定的版本号要求。

第三方配置
types 或者 typings：指定 TypeScript 的类型定义的入口文件。
unpkg：可以让 npm 上所有的文件都开启 CDN 服务。
browserslist：设置项目的浏览器兼容情况。babel 和 autoprefixer 等工具会使用该配置对代码进行转换。
lint-staged：lint-staged 是用于对 git 的暂存区的文件进行操作的工具，比如可以在代码提交前执行 lint 校验，类型检查，图片优化等操作。
```

##### 19、简单实现Webpack打包。

- 读取入口文件内容（使用 fs ）
- 分析入口文件，递归的方式去读取模块所依赖的文件并且生成AST语法树
  1. 安装 **@babel/parser** 转AST树）
- 根据AST语法树，生成浏览器可以运行的代码（遍历AST树）
  1. 安装 **@babel/traverse** 做依赖收集
  2. 安装 **@babel/core** 和 **@babel/preset-env** 让es6转es5

```javascript
const fs = require('fs');
const path = require('path');
const parser = require('@babel/parser')
const traverse = require('@babel/traverse').default
const babel = require('@babel/core')

const getModuleInfo = (file) => {
  //1 读文件
  const body = fs.readFileSync(file, 'utf8');  //读到路径下的文件内容

  //2 分析文件转AST树
  const ast = parser.parse(body, {   //body为需要解析的代码
    sourceType: 'module' //以es6的模块化语法解析
  })

  //3 依赖收集 
  const deps = {}
  traverse(ast, { //遍历ast
    ImportDeclaration({ node }) {  //把import类型的对象找出来
      const dirname = path.dirname(file)  //拿到index.js所在文件夹路径
      const abspath = './' + path.posix.join(dirname, node.source.value) //add.js文件的绝对路径
      deps[node.source.value] = abspath //key:'./add.js'  value:'xxx/add.js'
    }
  })

  //4.把ast->code
  const { code } = babel.transformFromAst(ast, null, {
    presets: ['@babel/preset-env']
  })
  console.log(code);

  const moduleInfo = { file, deps, code }
  return moduleInfo
}

//5. 递归获取所有依赖
const parseModules = (file) => {
  const entry = getModuleInfo(file)
  const temp = [entry]
  const depsGraph = {}

  for (let i = 0; i < temp.length; i++) {
    const deps = temp[i].deps //{ './add.js': './src/add.js', './minus.js': './src/minus.js' }
    if (deps) {
      for (const key in deps) {
        if (deps.hasOwnProperty(key)) {
          temp.push(getModuleInfo(deps[key]))
        }
      }
    }
  }

  temp.forEach(moduleInfo => {
    depsGraph[moduleInfo.file] = {
      deps: moduleInfo.deps,
      code: moduleInfo.code
    }
  })
  return depsGraph
}

//打包
const bundle = (file) => {
  const depsGraph = JSON.stringify(parseModules(file));
  //手写一个require 借助eval
  return `(function(grash) {
    function require(file) {
      function absRequire(relPath) {
        return require(grash[file].deps[relPath])
      }
      var exports = {};
      (function(require, code) {
        eval(code)
      })(absRequire, grash[file].code)
      return exports
    }
    require('${file}')
  })(${depsGraph})`
}

const result=bundle('./src/index.js')
fs.mkdirSync('./dist')
fs.writeFileSync('./dist/bundle.js', result)

```

##### 20、简单实现Vite打包。

```javascript
//用node启一个服务
const Koa = require('koa');
const app = new Koa()
const fs = require('fs')
const path = require('path')
const compilerDom = require('@vue/compiler-dom')  //引入vue源码  能识别template中的代码
const compilerSfc = require('@vue/compiler-sfc')  // 能识别script中的代码

function rewriteImport(content) {
  return content.replace(/ from ['|"]([^'"]+)['|"]/g, (s0, s1) => {
    //若以 ./  ../  / 开头的相对路径
    console.log(s0, s1);
    if (s1[0] !== '.' && s1[0] !== '/') {   //'vue
      return ` from '/@modules/${s1}'`   //去http://localhost:5173/@modules/vue
    } else {
      return s0
    }
  })
}

app.use((ctx) => {
  const { request: { url, query } } = ctx
  if (url === '/') {
    //读index.html
    ctx.type = 'text/html'  //设置类型
    let content = fs.readFileSync('./index.html', 'utf8')  //读文件
    // console.log(content);

    ctx.body = content//content输出给前端
  }
  else if (url.endsWith('.js')) {  //js文件  /src/main.js
    const p = path.resolve(__dirname, url.slice(1))  //   src/main.js  拿到文件的绝对路径
    ctx.type = 'application/javascript'
    const content = fs.readFileSync(p, 'utf8')
    ctx.body = rewriteImport(content)
  }
  else if (url.startsWith('/@modules')) { //  '/@modules/vue'
    const prefix = path.resolve(__dirname, 'node_modules', url.replace('/@modules/', ''))  // 'vue'
    const module = require(prefix + '/package.json').module //读取package.json中的module字段   拿到vue的模块源码地址
    const p = path.resolve(prefix, module)  // 拿到vue的模块源码的终极地址
    const ret = fs.readFileSync(p, 'utf8')  //读取文件
    ctx.type = 'application/javascript'
    ctx.body = rewriteImport(ret)  //递归 防止vue源码又用到了其它模块
  }
  else if (url.indexOf('.vue') > -1) {
    const p = path.resolve(__dirname, url.split('?')[0].slice(1)) // src/App.vue
    const { descriptor } = compilerSfc.parse(fs.readFileSync(p, 'utf8'))
    
    console.log(descriptor);
    if (!query.type) { // 返回.vue文件的js部分
      ctx.type = 'application/javascript'
      ctx.body = `
        ${rewriteImport(descriptor.script.content.replace('export default ', 'const __script = '))}
        import { render as __render } from "${url}?type=template"
        __script.render = __render
        export default __script
      `
    } else if (query.type === 'template') { // 返回.vue文件的html部分
      const template = descriptor.template
      const render = compilerDom.compile(template.content, {mode: 'module'}).code
      ctx.type = 'application/javascript'
      ctx.body = rewriteImport(render)
    }

  }
  else if (url.endsWith('.css')) {
    const p = path.resolve(__dirname, url.slice(1))
    const file = fs.readFileSync(p, 'utf8')
    const content = `
      const css="${file.replace(/\n/g, '')}"
      let link=document.createElement('style')
      link.setAttribute('type','text/css')
      document.head.appendChild(link)
      link.innerHTML = css
      export default css
    `
    ctx.type = "application/javascript"
    ctx.body = content
  }
})

app.listen(5173, () => {
  console.log('listening on port 5173');
})
```

### 移动端

##### 1、App开发分类？

```javascript
1、原生应用(native App)
原生 App 使用与手机操作系统相同的语言。iOS 的原生 App 使用 Objective-C 语言或 Swift 语言，安卓使用 Java 语言或 Kotlin 语言。由于跟底层系统的语言和技术模型一致，所以原生 App 的性能和用户体验都很好。
优点：较好的性能和体验。以使用系统的所有硬件和软件 API，比如 GPS、摄像头、麦克风、加速计、通知推送等等，能充分发挥系统的潜力。
缺点：成本太高，开发和调试成本相对较高，时间周期长。
2、Web 应用(web app)
Web App 是使用网页做的应用程序，必须在浏览器中使用。 比如，你在浏览器中收发邮件，就是在使用 Web App。
优点：对于开发者来说，Web App 写起来比较快，调试容易，不需要应用商店的批准就能发布。
缺点：网页通过浏览器渲染，性能不如原生 App，不适合做性能要求较高的页面。
3、混合应用(hybrid App)
混合 App（hybrid App）顾名思义就是原生 App 与 Web App 的结合。它的壳是原生 App，但是里面放的是网页。 可以理解成，混合App里面隐藏了一个浏览器，用户看到的实际上是这个隐藏浏览器渲染出来的网页。混合 App 从上到下分成三层：HTML5 网页层、网页引擎层（本质上是一个隔离的浏览器实例）、容器层。所谓API Bridge就是容器在底层接口和网页之间，建立一座桥梁，让双方通信。容器一旦接到网页的请求，就根据请求去调用底层系统的 API，然后再返回结果给网页。API Bridge 往往以 JavaScript 语言提供，方便网页调用，这时又称为 JSbridge。
优点：
1、跨平台。Web 技术是跨平台的，开发者只写一次页面，就能支持多个平台。
2、灵活性。混合 App 的灵活性大，很容易集成多种功能。一方面，混合 App 很容易加载外部的 H5 页面，实现 App 的插件结构；另一方面，Web 页面可以方便地调用外部的 Web 服务。
3、开发调试方便。
缺点：混合 App 的主要缺点是，由于存在网页引擎的中间层，所以性能比较欠缺，不仅不如原生 App，而且由于 WebView 不是全功能浏览器，可能比 Web App 都要慢一些。由于跨平台，可能需要处理兼容性问题。
```

### TypeScript

------

##### 1、TypeScript的基础类型有几种？

```javascript
Boolean：布尔类型。
String：字符串类型。
Number：数字类型。
Tuple：元组类型。表示数组类型各元素类型可不相同。
Array：数组类型。
Enum:枚举类型。枚举默认0开始，也可以手动指定枚举值。
Any: 任何类型。
Void:与Any相反，表示没有任何类型。
Never：表示那些永远不存在值的类型。常用来做抛出异常处理或不会有返回值的函数表达式。Any类型不能赋值给Never类型。
Null:Null类型。
Undefined:Undefined类型。
Object:除去非原始类型。
```

##### 2、const和readonly的区别？枚举和常量枚举的区别？

```javascript
const与readonly的区别
1、const用于防止变量的值被修改。readonly用于防止变量的属性被修改。
2、const在运行时检查，readonly在编译时检查。
枚举和常量枚举的区别
枚举：会被编译成一个对象，可以当做对象使用。
常量枚举：在编译期间会被删除掉。
```

##### 3、TypeScript 中 type 和 interface 的区别?

```javascript
相同点：
1、都可以用来描述对象或者函数
2、都可以实现扩展
区别：
1、type可以声明基本类型、联合类型等
2、多个相同的接口会合并，type则会报错
3、接口能被派生类实现，type则不能
```

##### 4、TypeScript访问修饰符。

```javascript
public: 在任何地方访问。
private: 只能在类内部访问。
protected：只能在类的内部和子类中访问。
readonly：属性为只读。
```

##### 5、TypeScript 中对象展开会有什么副作用吗？

```javascript
1、展开对象后面的属性会覆盖前面的属性；
2、仅包含对象自身的可枚举属性，不可枚举的属性将会丢失。
```

##### 6、keyof 和 typeof 关键字的作用？

```javascript
keyof：索引类型查询操作符 获取索引类型的属性名，构成联合类型。
typeof：获取一个变量或对象的类型。
```

##### 7、简述Typescript内置工具类型。

```javascript
Exclude:过滤某些不需要的属性。
Record:为属性指定数据类型。
Pick：获取对象的子属性。
Required：所有属性都是必须的。
Partial：所有属性都是可选的。
ReturnType：获取方法的返回类型的。
```

##### 8、declare，declare global是什么？

```javascript
declare关键字用来定义.d.ts文件。
declare：用来定义全局变量、全局函数、模块等。
declare global：为全局对象 window 增加新的属性。
```

##### 9、TS高级类型有哪些？

交叉类型

通过&将多个类型合并一个类型，包含了所需的所有类型的特性，本质上是一种并的操作。T&U

```js
function extend<T , U>(first: T, second: U) : T & U {
     let result: <T & U> = {}
     for (let key in first) {
        result[key] = first[key]
     }
     for (let key in second) {
     if(!result.hasOwnProperty(key)) {
        result[key] = second[key]
        }
     }
     return result
}
```

联合类型

联合类型的语法规则和逻辑“或”的符号一直，表示其类型为连接的多个类型中的任意一个。T|U

```js
function formatCommandline(command: string[] | string) {
     let line = '';
     if (typeof command === 'string') {
     	line = command.trim();
     } else {
     	line = command.join(' ').trim();
     }
}
```

类型索引

keyof类型鱼Object.keys，用于获取一个接口中Key的联合类型。

```ts
interface Button {
 type: string
 text: string
}
type ButtonKeys = keyof Button
// 等效
type ButtonKeys = "type" | "text"
```

类型约束

通过关键字extend进行约束。

```js
type BaseType = string | number | boolean
function copy<T extends BaseType>(arg: T): T {
 	return arg
}

function getValue<T, K extends keyof T>(obj: T, key: K) {
 return obj[key]
}
```

映射类型

通过in关键字做类型的映射，遍历已有接口的key或是遍历联合类型。

```ts
type Readonly<T> = {
 	readonly [P in keyof T]: T[P];
};
interface Obj {
 	a: string
 	b: string
}
type ReadOnlyObj = Readonly<Obj>
```

条件类型

```ts
T extends U ? X : Y
```

##### 10、枚举类型。

数字枚举

当我们声明一个枚举来类型时，虽然没有它们赋值，当时它们的值其实是默认的数字类型，而且默认从0开始依次累加。

```ts
enum Direction {
 Up, // 0
 Down, // 1
 Left, // 2
 Right // 3
}
```

字符串枚举

```js
enum Direction {
 Up = 'Up',
 Down = 'Down',
 Left = 'Left',
 Right = 'Right'
}
```

异构枚举

```js
enum BooleanLikeHeterogeneousEnum {
 No = 0,
 Yes = "YES",
}
```

### 其他

##### 1、前端的几种鉴权方式。

```javascript
Session：用户登录后，服务端会返回一个sessionID，客户端会将sessionID存到cookie中，等到客户端第二次请求，会携带cookie信息(包括sessionID)，服务器接收到sessionID后，会查找对应的session信息。如果能找到，说明校验通过可以进行后续操作。如果校验不通过，说明sessionID已经失效，需要用户重新登录。由于session是存储在服务端，所以当用户过多时，会对服务端造成压力。且session无法在多个服务器之间共享，可以通过redis缓存session数据来实现分布式部署。由于sessionID是存储在cookie中，如果浏览器被禁止使用cookie，可以加sessionID以参数的形式放在url中。

Token：用户登录后，服务端会返回一个token令牌，客户端会将其保存起来了，然后每次请求通过将token放在请求头Header里面发送给服务端。服务端接受到token后会根据token信息去数据库中查询用户信息进行验证。如果验证通过，就可以进行下一步操作，反之校验失败。通过这种方式服务端不用存储token，从而减轻服务端压力。
Refresh Token：主要作用是刷新token。当token过期时，会检验Refresh Token 是否过期，如果Refresh Token未过期，那么就会重新生成一个token返回，反之，就需要用户重新登录以此来获得新的token了。使用数据库内存储token会导致查询时间过长，因此可以将其放入到redis内存中。

JWT：即JSON Web Token，是一种token的编码方式。通过添加请求头Header中的Authorization属性Bearer来添加JWT。JWT通常由三部分组成header，payload，sign三部分组成。header是用来指定签名的算法，payload就是要加密的信息，sign就是密钥跟算法生成的签名。使用JWT是以将加密后的数据存储在客户端，服务端只需要对加密后的数据进行解密即可(不需要查询数据库)。因为JWT包含了用户的认证信息，因此需要将JWT的有效期设置较短和采用HTTPS加密传输。

SSO：即单点登录。不同的项目，一次登录，全线通用。
1、主域名相同子域名不同。比如(wenku.baidu.com,tieba.baidu.com)。可以将cookie.domain设置为主域名即可(即共享cookie来判断用户是否登录)。
2、主域名不同。
用户进入A系统，没有登录凭证，A系统就会跳到SSO，在SSO登录成功后，通过接口会做两件事，在SSO种下凭证信息(即在SSO域名写入cookie)和返回ticket(token用来做接口认证的)。客户端拿到ticket，保存起来，带着ticket发起请求。如果ticket校验通过，就可以进行后续的操作。
用户进入B系统，没有登录登录凭证，此时会跳转到SSO，SSO登录过(即之前A系统登录是写入的cookie信息)，系统下有凭证信息，不用再次登录。直接下发ticket，客户端拿ticket，保存起来，发起请求时携带ticket就能完成校验了。
上述的方法在浏览器中，如果SSO返回的数据系统A请求时是无法通过cookie、localStorage等方式携带的。可以通过JWT的方式实现跨域认证。
```

##### 3、对节流与防抖的理解？

```javascript
函数防抖：指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
函数节流：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。

function debounce(fn, wait) {
  let timer = null;
  return function() {
    let context = this,
      args = [...arguments];

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

function throttle(fn, delay) {
  let preTime = Date.now();
  return function() {
    var context = this,
      args = [...arguments],
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}
```

##### 4、懒加载的实现原理？

```javascript
懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。懒加载的好处：
1、减少无用资源的加载。使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。
2、提升用户体验。如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。
3、防止加载过多图片而影响其他资源文件的加载 ：会影响网站应用的正常使用。
```

##### 5、微前端几种实现方式？

```javascript
微前端是一种新的架构方式，微前端包括应用注册、路由管理、应用加载器三个模块。微前端的架构方式所带来的好处也是显而易见的。
1、降低代码解耦。
2、微前端独立部署。
3、团队业务拆垂直分更高效。

常见的实现方式
iframe
优点
1、实现简单。
2、天然沙箱隔离机制。
缺点
1、iframe 阻塞主页面加载。
2、主页面和 iframe 共享最大允许的 HTTP 链接数。
3、浏览器后退按钮无效。

微前端框架single-spa。分为两部分子应用和容器应用。容器应用主要负责注册应用，当 url 命中子应用的路由时激活并挂载子应用，或者当子应用不处于激活状态时，将子应用从页面中移除卸载。比如(qiankun微前端）。
优点
1、纯前端解决方案。
2、可以使用多种技术栈。
缺点
1、上手成本高。
2、跨应用的联调变得复杂。
                                                
```

##### 6、对Web Component的理解。

```javascript
Web Component是一套用于封装具有复用性、互用性前端组件的技术规范。包括三种核心技术：
1、自定义元素。创建自定义HTML元素或扩展内置元素。通过定义class 继承对应的HTML元素接，然后通过customElements.define API进行注册。该API有三个参数，第一个是组件名称必须是字符串类型且必须包含连字符"-"。第二个参数则是构造函数，即自定义的类。第三个参数仅对扩展元素生效，通过extends指定被扩展的原生元素名称。
2、HTML Template。组件模板，template元素是惰性的，其元素自身以及其内部所有的元素均不会渲染（内部被一个DocumentFragment包裹）。
3、Shadow Dom。创建一个与全局隔离的独立作用域，全局作用域和独立作用域互不影响。通过attchShadow开启Shadow Dom。

Web Component 生命周期
connectedCallback：当元素被加入HTML文档后，与document建立连接后触发。（类似于Vue mounted）
disconnectedCallback：当元素被从HTML文档中删除后触发。
attributeChangeCallback：监听属性变化，每次属性改变都会触发。
adoptedCallback：元素从当前document移动到其他document触发。

class CustomButton extends HTMLButtonElement {
    constructor() {
        super();
        // 开启shadow dom模式
        this._shadowRoot = this.attchShadow({mode:'open'});
    }
}

// 定义web component
customElements.define('custom-button', CustomButton, {extends: 'button'});

// 使用web component
<button is="custom-button">Button</button>
```

##### 7、Git 分支以及提交合并规则。

```javascript
master：只记录已交付生成环境的代码，只接受merge不接受push，而且只接受release分支和hotfix分支的merge请求。
release：可以理解为即将发布生成环境代码分支，发布成功后，需要将其merge到master分支，只接受develop分支的merge请求。
hotfix：用来应对突发情况，用户修复线上的紧急的bug，从最新的master分支pull而来，完成上线后合并到master分支。
develop：开发阶段接受由不同成员负责的所有feature分支的merge请求，可以将其成为集成分支。develop可以从最新的master、hotfix、release分支pull下来，并且只能被merge到release分支。
featrue：针对单个业务功能的分支，从develop 分支pull下来并且只能merge到develop分支。相当于本地的开发分支。
```

##### 8、前端实现埋点上报是怎么实现的？

```javascript
1、基于ajax的埋点上报
一般而言，埋点域名并不是当前域名，因此请求会存在跨域风险，且如果ajax配置不正确可能会浏览器拦截。因此使用ajax这类请求并不是万全之策。

2、基于img的埋点上报
当我们使用script和link进行埋点上报时，需要挂载到页面上，而反复操作dom会造成页面性能受影响，而且载入js/css资源还会阻塞页面渲染，影响用户体验，因此对于需要频繁上报的埋点而言，script和link并不合适。
通常使用img标签去做埋点上报，img标签加载并不需要挂载到页面上，基于js去new image()，设置其src之后就可以直接请求图片。通常埋点上报会使用gif图，合法的 GIF 只需要 43 个字节。

3、基于Navigator.sendBeacon的埋点上报
Navigator.sendBeacon方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选）。sendBeacon是异步的，不会影响当前页到下一个页面的跳转速度，且不受同域限制。这个方法还是异步发出请求，但是请求与当前页面脱离关联，作为浏览器的任务，因此可以保证会把数据发出去，不拖延卸载流程。
```

### NodeJS

##### 1、说说你对Node.js 的理解？优缺点？应用场景？

```javascript
Node.js 是一个服务器端的、非阻塞式I/O的、事件驱动的JavaScript运行环境。

非阻塞异步
Nodejs采用了非阻塞型I/O机制，在做I/O操作的时候不会造成任何的阻塞，当完成之后，以事件的形式通知执行操作。

事件驱动
事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。
```

##### 2、Node. js 有哪些全局对象？

```
全局对象分成两类:真正的全局对象和模块级别的全局变量。

真正的全局对象
1、Class:Buffer。可以处理二进制以及非Unicode编码的数据。
2、process。进程对象，提供有关当前进程的信息和控制。
3、console。控制台输出信息。
4、clearInterval、setInterval。设置定时器与清除定时器。
5、clearTimeout、setTimeout。设置延时器与清除延时器。
5、global。全局命名空间对象，即最顶层对象。类似js中的window对象。

模块级别的全局对象
1、__dirname。获取当前文件所在的路径，不包括后面的文件名。
2、__filename。获取当前文件所在的路径和文件名称，包括后面的文件名称。
3、exports。module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容。
4、module。对当前模块的引用，通过module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容。
5、require。用于引入模块、 JSON、或本地文件。
```

##### 3、Nodejs中的事件循环机制理解?

```
NodeJS中，事件循环是基于libuv实现，libuv是一个多平台的专注于异步IO的库(提供的功能不仅仅是io，包括进程、线程、信号、定时器、进程间通信等)。可分为六个阶段。

timers阶段。这个阶段执行timer(setTimeout、setInterval)的回调。
I/O事件回调阶段(I/O callbacks)。执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。
闲置阶段(idle, prepare)。仅系统内部使用
轮询阶段(poll)。检索新的 I/O 事件;执行与 I/O 相关的回调，其余情况 node 将在适当的时候在此阻塞。
检查阶段(check)。setImmediate() 回调函数在这里执行。
关闭事件回调阶段(close callback)。一些关闭的回调函数。

事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。
当一个请求被压入事件队列中时，会判断该任务是否I/O任务，如果是，则直接进入相应的队列。如果不是，那么就进入I/O任务队列，在(poll)轮询阶段,判断任务队列是否为空，如果不为空，就进入I/O callback阶段。如果任务队列为空，就分别判断是否有存在过期定时器(timer)和setImmediate,如果没有直接进入I/O callback阶段，如果有就进入对应的阶段timer阶段或check阶段，等到执行完成就进入I/O callback阶段。

在Node中，同样存在宏任务和微任务
微任务
process.nextTick
romise.then回调

宏任务
setTimeout、setInterval
IO事件
setImmediate
close事件

```

##### 4、Node 文件查找的优先级以及 Require 方法的文件查找策略？

```
Require 方法
见上面require 具体实现原理。
优先级
1、缓存的模块优先级最高。
2、如果是内置模块，则直接返回，优先级仅次缓存的模块。
3、如果是绝对路径 / 开头，则从根目录找。
4、如果是相对路径 ./开头，则从当前require文件相对位置找。
5、如果文件没有携带后缀，先从js、json、node按顺序查找。
6、如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js。
7、如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录。
```

##### 5、说说对中间件概念的理解。

```
中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的.在NodeJS中，中间件主要是指封装http请求细节处理的方法。
```

### 设计模式

##### 1、工厂模式

```js
工厂模式是用来创建对象的常见设计模式，在不暴露创建对象的具体逻辑，而是将逻辑进行封装，那么它就可以被称为工厂。工厂模式又叫做静态工厂模式，由一个工厂对象决定创建某一个类的实例。

function Factory(career){
    if(this instanceof Factory){
        var a = new this[career]();
        return a;
    }else{
        return new Factory(career);
    }
 }
 // 
Factory.prototype={
    'coder': function(){
        this.careerName = ' '
        this.work = [' ', ' Bug'] 
    },
    'hr': function(){
        this.careerName = 'HR'
        this.work = [' ', ' ']
    },
    'driver': function () {
        this.careerName = ' '
        this.work = [' ']
    },
    'boss': function(){
        this.careerName = ' '
        this.work = [' ', ' ', ' ']
    }
 }
 let coder = new Factory('coder')
 console.log(coder)
 let hr = new Factory('hr')
```

##### 2、单例模式

```js
保证一个类只能被实例一次，每次获取的时候，如果该类已经创建过实例则直接返回该实例，否则创建一个实例保存并返回。
tips:我们常见到的登录弹窗，要么显示要么隐藏，不可能同时出现两个弹窗，下面我们通过一个类来模拟弹窗。


function Singleton(name) {
     this.name = name;
     this.instance = null;
 }
 // getName()
 Singleton.prototype.getName = function() {
 	console.log(this.name)
 };
 // 
 Singleton.getInstance = function(name) {
     if(!this.instance) {
      	this.instance = new Singleton(name);
     }
 	 return this.instance
 };
 const a = Singleton.getInstance('a');
 const b = Singleton.getInstance('b');
 console.log(a === b);
```

##### 3、装饰器模式

```
装饰者模式能够在不更改源代码自身的情况下，对其进行职责添加。
```

##### 4、发布订阅模式

```js
它定义对象之间的1对N的依赖关系，当其中一个对象发生变化时，所有依赖于它的对象都会得到通知。与观察模式有所不同，观察者模式，观察者和被观察者是之间相互通信的，而发布订阅模式发布者和订阅者是没有直接通信的，是通过调度中心推送信息，发布者通过给调度中心发送信息，然后有调度中心推送给对应的订阅者。
tips:当你给DOM绑定一个事件就已经使用了发布订阅模式，通过订阅DOM上的click事件，当被点击时会向订阅者发布消息。

 // 调度中心，发布者与订阅者的桥梁
 class PubSub {
  constructor() {
    this.messages = {};
    this.listeners = {};
  }
  // 添加发布者
  publish(type, content) {
    const existContent = this.messages[type];
    if (!existContent) {
      this.messages[type] = [];
    }
    this.messages[type].push(content);
  }
  // 添加订阅者
  subscribe(type, cb) {
    const existListener = this.listeners[type];
    if (!existListener) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(cb);
  }
  // 通知
  notify(type) {
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb, index) => cb(messages[index]));
  }
 }

 发布者代码
 class Publisher {
     constructor(name, context) {
         this.name = name;
         this.context = context;
     }
     publish(type, content) {
     	 this.context.publish(type, content);
     }
 }

 订阅者代码
 class Subscriber {
     constructor(name, context) {
         this.name = name;
         this.context = context;
     }
     subscribe(type, cb) {
     	 this.context.subscribe(type, cb);
     }
}

const TYPE_A = 'music';
const TYPE_B = 'movie';
const TYPE_C = 'novel';

// 创建调度中心
const pubsub = new PubSub();
// 创建发布者A
const publisherA = new Publisher('publisherA', pubsub);
publisherA.publish(TYPE_A, 'we are young');
publisherA.publish(TYPE_B, 'the silicon valley');
// 创建发布者B
const publisherB = new Publisher('publisherB', pubsub);
publisherB.publish(TYPE_A, 'stronger');
// 创建发布者C
const publisherC = new Publisher('publisherC', pubsub);
publisherC.publish(TYPE_C, 'a brief history of time');
// 创建订阅者A
const subscriberA = new Subscriber('subscriberA', pubsub);
// 调用subscribe方法（其实调用的是PubSub中的subscribe方法将订阅者添加到订阅类型位TYPE_A的订阅者者列表中）
subscriberA.subscribe(TYPE_A, res => {
 	console.log('subscriberA received', res)
});
const subscriberB = new Subscriber('subscriberB', pubsub);
subscriberB.subscribe(TYPE_C, res => {
 	console.log('subscriberB received', res)
});
const subscriberC = new Subscriber('subscriberC', pubsub);
subscriberC.subscribe(TYPE_B, res => {
 	console.log('subscriberC received', res)
});
// 通知订阅者
pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
```

##### 5、**策略模式**

```
策略模式指的是定义一系列算法，把他们一个个封装起来，目的就是将算法的使用和算法的实现分离开来。同时它还可以用来封装一系列的规则，比如常见的表单验证规则，只要这些规则指向的目标一致，并且可以被替换使用，那么就可以用策略模式来封装它们。
```

##### 6、观察者模式

```js
观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。

被观察者
class Subject {
     constructor() {
        this.observerList = [];
     }
     addObserver(observer) {
     	this.observerList.push(observer);
     }
     removeObserver(observer) {
     	const index = this.observerList.findIndex(o => o.name === observer.name);
     	this.observerList.splice(index, 1);
     }
     notifyObservers(message) {
         const observers = this.observeList;
         observers.forEach(observer => observer.notified(message));
     }
 }

观察者
class Observer {
     constructor(name, subject) {
     	this.name = name;
     	if (subject) {
     		subject.addObserver(this);
        }
      }
      notified(message) {
     	console.log(this.name, 'got message', message);
      }
 }

使用代码
// 创建被观察者对象
const subject = new Subject();
// 创建观察者对象A
const observerA = new Observer('observerA', subject);
// 创建观察者对象B
const observerB = new Observer('observerB');
subject.addObserver(observerB);
subject.notifyObservers('Hello from subject');
subject.removeObserver(observerA);
subject.notifyObservers('Hello again')
```

### 项目亮点

##### 1、脚本加载失败怎样进行重新加载。

```js
1、什么时候重试？
通过监听监听window.onerror事件来监听脚本加载错误（这里注意一点脚本加载错误是不会事件冒泡的，所以只能在事件捕获阶段监听）。
window.addEventListener(
    'error',
    e => {
      // 会捕获到其他错误，这里只需要捕获脚本加载错误
      if (e.target.tagName !== 'SCRIPT') return;
    },
    true
  );
2、通过怎样的方式去重新加载？
一般会维护一个域名列表，通过遍历域名进行脚本地址替换重试，这里需要注意的是，不能采用动态创建脚本方式添加脚本，因为这样可能无法导致保证脚本按照顺序加载，比如需要重试的b.js 是被后面其他js文件所依赖的，那么这时候需要阻塞浏览器的脚本加载，所以应该用document.write 方法加载脚本，才能保证按照顺序加载。
```

##### 2、在版本发布后怎样通知用户更新页面（当用户停留长时间停留在某个页面时，通知用户版本更新请刷新页面）。

```
```
