#### 代码实现

##### 1、使其a == 1 && a == 2 && a == 3 成立。

```javascript
// 主要考虑的是隐式转化。 
const obj = {
      value: 1,
      valueOf() {
        return this.value++;
      },
  };
  console.log(obj == 1 && obj == 2 && obj == 3);
```

##### 2、const [a,b] = {a:1,b:2} 成立。

```javascript
// 主要考虑如何实现一个迭代器。
 Object.prototype[Symbol.iterator] = function () {
      return Object.values(this)[Symbol.iterator]();
 };
```

##### 3、不用循环和数组内置方法，怎么给数组求和？

```javascript
function sum(array) {
      function f(i) {
        return i >= array.length ? 0 : array[i] + f(i + 1);
      }
      return f(0);
}
```

##### 4、在不改变上面代码的情况下，修改obj对象。

```javascript
// 修改Object原型重写get方法
const o = (function () {
      const obj = {
        a: 1,
        b: 2,
      };
      return {
        get: function (k) {
          return obj[k];
        },
      };
})();

Object.defineProperty(Object.prototype, "name", {
    get() {
        return this;
    },
});
const obj = o.get("name");
obj.a = "name";
console.log(o.get("a"));
```

5、并发请求，按照数组的顺序请求并按照顺序返回。

```javascript
const urls = [];
for (let i = 1; i <= 10; i++) {
    urls.push(`https://jsonplaceholder.typicode.com/posts/${i}`);
}
concurRequest(urls, 3).then((res) => {
    console.log(res);
});

function concurRequest(urls, maxNum) {
    return new Promise((resolve) => {
        if (urls.length === 0) {
            resolve([]);
            return;
        }
        const results = [];
        let index = 0;  // 下一个请求的下标
        let count = 0;   // 返回数据数量
        async function request() {
            if (index === urls.length) {
                return;
            }
            const i = index;
            const url = urls[index];
            index++;
            try {
                const response = await fetch(url);
                results[i] = response;
            } catch (err) {
                results[i] = err;
            } finally {
                count++;
                if (count === urls.length) {
                    resolve(results);
                }
                request();
            }
        }

        const times = Math.min(maxNum, urls.length);
        for (let i = 0; i < times; i++) {
            request();
        }
    });
}
```

##### 6、如何不借助第三个变量完成上面的交换。

```javascript
var a = 6;
var b = 5;
a = a + b;
b = a - b;
a = a - b;
```

##### 7、new 操作符的实现原理。

```javascript
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
```

##### 8、实现call函数。

```javascript
Function.prototype.Call = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }
  // 获取参数
  let args = [...arguments].slice(1),
      result = null;
  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;
  // 将调用函数设为对象的方法
  context.fn = this;
  // 调用函数
  result = context.fn(...args);
  // 将属性删除
  delete context.fn;
  return result;
};
```

9、实现节流和防抖。

```javascript
// 防抖
function debounce(fn, wait) {
  let timer = null;
  return function() {
    let context = this,
      args = [...arguments];

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

// 节流
function throttle(fn, delay) {
  let preTime = Date.now();
  return function() {
    var context = this,
      args = [...arguments],
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}
```

##### 9、手动实现Object.create。

```javascript
 function create(obj){
     function F() {}
     F.prototype = obj;
     return new F();
 }
```

##### 10、手写 instanceof 方法。

```javascript
function myInstanceof(left, right) {
  let proto = Object.getPrototypeOf(left), // 获取对象的原型
      prototype = right.prototype; // 获取构造函数的 prototype 对象

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;

    proto = Object.getPrototypeOf(proto);
  }
}
```

##### 11、实现AJAX请求。

```javascript
const SERVER_URL = "/server";
let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open("GET", SERVER_URL, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);
```

##### 12、实现对象深拷贝。

```javascript
// MessageChannel 用于通信管道，a和b都能互相通信，因为通信是发生在线程之间(进程之间的数据是互不共享的)，所以传递对象是在内存中分配了不同的地址，所以可以用来做深拷贝。
function deepCopy(obj) {
  return new Promise((resolve) => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = (ev) => resolve(ev.data);
    port1.postMessage(obj);
  });
}
```

#### 代码输出

```javascript
// 对象的属性只能是string、number、symbol
var a = { sex: "man" };
var b = { name: "name" };
var c = { age: "age" };

a[b] = 123; // 这里调用对象toString()方法将其转化为[object Object] a['[object Object]']
a[c] = 234; // a['[object Object]']
console.log(a[b]);
```

```javascript
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 }; // 因为 a = {n:2}，将a重新赋值了，所以a的指向变了，切断了与原对象之间的联系。
console.log(a.x); // undefined
console.log(b.x); // {n:2}
```

