#### 代码实现

##### 1、使其a == 1 && a == 2 && a == 3 成立。

```javascript
// 主要考虑的是隐式转化。 
const obj = {
      value: 1,
      valueOf() {
        return this.value++;
      },
  };
  console.log(obj == 1 && obj == 2 && obj == 3);
```

##### 2、const [a,b] = {a:1,b:2} 成立。

```javascript
// 主要考虑如何实现一个迭代器。
 Object.prototype[Symbol.iterator] = function () {
      return Object.values(this)[Symbol.iterator]();
 };
```

##### 3、不用循环和数组内置方法，怎么给数组求和？

```javascript
function sum(array) {
      function f(i) {
        return i >= array.length ? 0 : array[i] + f(i + 1);
      }
      return f(0);
}
```

##### 4、在不改变上面代码的情况下，修改obj对象。

```javascript
// 修改Object原型重写get方法
const o = (function () {
      const obj = {
        a: 1,
        b: 2,
      };
      return {
        get: function (k) {
          return obj[k];
        },
      };
})();

Object.defineProperty(Object.prototype, "name", {
    get() {
        return this;
    },
});
const obj = o.get("name");
obj.a = "name";
console.log(o.get("a"));
```

5、并发请求，按照数组的顺序请求并按照顺序返回。

```javascript
const urls = [];
for (let i = 1; i <= 10; i++) {
    urls.push(`https://jsonplaceholder.typicode.com/posts/${i}`);
}
concurRequest(urls, 3).then((res) => {
    console.log(res);
});

function concurRequest(urls, maxNum) {
    return new Promise((resolve) => {
        if (urls.length === 0) {
            resolve([]);
            return;
        }
        const results = [];
        let index = 0;  // 下一个请求的下标
        let count = 0;   // 返回数据数量
        async function request() {
            if (index === urls.length) {
                return;
            }
            const i = index;
            const url = urls[index];
            index++;
            try {
                const response = await fetch(url);
                results[i] = response;
            } catch (err) {
                results[i] = err;
            } finally {
                count++;
                if (count === urls.length) {
                    resolve(results);
                }
                request();
            }
        }

        const times = Math.min(maxNum, urls.length);
        for (let i = 0; i < times; i++) {
            request();
        }
    });
}
```

##### 6、如何不借助第三个变量完成上面的交换。

```javascript
var a = 6;
var b = 5;
a = a + b;
b = a - b;
a = a - b;
```

##### 7、new 操作符的实现原理。

```javascript
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
```

##### 8、实现call函数。

```javascript
Function.prototype.Call = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }
  // 获取参数
  let args = [...arguments].slice(1),
      result = null;
  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;
  // 将调用函数设为对象的方法
  context.fn = this;
  // 调用函数
  result = context.fn(...args);
  // 将属性删除
  delete context.fn;
  return result;
};
```

9、实现节流和防抖。

```javascript
// 防抖
function debounce(fn, wait) {
  let timer = null;
  return function() {
    let context = this,
      args = [...arguments];

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

// 节流
function throttle(fn, delay) {
  let preTime = Date.now();
  return function() {
    var context = this,
      args = [...arguments],
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}
```

##### 9、手动实现Object.create。

```javascript
 function create(obj){
     function F() {}
     F.prototype = obj;
     return new F();
 }
```

##### 10、手写 instanceof 方法。

```javascript
function myInstanceof(left, right) {
  let proto = Object.getPrototypeOf(left), // 获取对象的原型
      prototype = right.prototype; // 获取构造函数的 prototype 对象

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;

    proto = Object.getPrototypeOf(proto);
  }
}
```

##### 11、实现AJAX请求。

```javascript
const SERVER_URL = "/server";
let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open("GET", SERVER_URL, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);
```

##### 12、实现对象深拷贝。

```javascript
// MessageChannel 用于通信管道，a和b都能互相通信，因为通信是发生在线程之间(进程之间的数据是互不共享的)，所以传递对象是在内存中分配了不同的地址，所以可以用来做深拷贝。
function deepCopy(obj) {
  return new Promise((resolve) => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = (ev) => resolve(ev.data);
    port1.postMessage(obj);
  });
}
```

##### 13、判断一个函数是否Promise Like函数。

```javascript
// 判断是否是Promise A+规范。对象promise是一个函数或对象，同时还有一个then方法即可
function isPromiseLike(value) {
   return value !== null && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function'
}
```

##### 14、手动实现一个Promise.all函数。

```javascript
Promise.all = function (params) {
    let res,rej;
    let count = 0;
    let fuFilledCount = 0;
    // 返回结果
    const result = [];
    const p = new Promise((resolve,reject) => {
        res = resolve;
        rej = reject;
    });
    for(const value of params) {
        const i = count;
        count++;
        Promise.resolve(value).then(data=> {
           result[i] = data;
           fuFilledCount++;
            // 表示已经全部完成
           if(fuFilledCount === count) {
               res(result)
           }
        },rej)
    }
    if(count === 0) {
        res(result)
    }
    return p;
}
```

##### 15、手写Promise.race函数。

```javascript
// Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.
Promise.race = function (args) {
  return new Promise((resolve, reject) => {
    for (let i = 0, len = args.length; i < len; i++) {
      args[i].then(resolve, reject)
    }
  })
}
```

##### 16、实现两大整数相加。

```javascript
var sum = function (a = "", b = "") {
  let result = "";
  let carry = 0;
  const max = Math.max(a.length, b.length);
  a = a.padStart(max, "0");
  b = b.padStart(max, "0");
  for (let i = max - 1; i >= 0; i--) {
    // 超过10就要进一位
    const n = +a[i] + +b[i] + carry;
    // 进位的值
    carry = Math.floor(n / 10);
    // 将结果累加
    result = (n % 10) + result;
  }
  // 说明还需要往前进一位
  if (carry) {
    result = "1" + result;
  }
  return result;
};
```

##### 17、数组转化成树结构数据。

```javascript
let array = [
    { id: 1, name: '部门1', pid: 0 },
    { id: 2, name: '部门1-2', pid: 1 },
    { id: 6, name: '部门1-2-1', pid: 2 },
    { id: 3, name: '部门1-3', pid: 1 },
    { id: 4, name: '部门4', pid: 3 },
    { id: 5, name: '部门5', pid: 4 },
]
function arrayToTree(items) {
    const result = [];
    const treeMap = {};
    // 所有数据转化成map数据结构
    for (const item of array) {
      treeMap[item.id] = { ...item, children: [] }
    }
    for (const item of array) {
      const id = item.id;
      const pid = item.pid;
      const tree = treeMap[id];
      // 获取根节点数据
      if (pid === 0) {
        result.push(tree);
      } else {
        if (!treeMap[pid]) {
          treeMap[pid] = {
            children: []
          };
        }
        // 采用对象的引用，将子节点添加到父节点
        treeMap[pid].children.push(tree);
      }
    }
    return result;
 }
```

##### 18、实现深拷贝。

```javascript
function cloneDeep(obj = {}) {
    if (obj === null) return null;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    if (typeof obj !== "object") return obj;
    let cloneObj = Object.create(obj);
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloneObj[key] = cloneDeep(obj[key]);
        }
    }
    return cloneObj;
}
```

##### 19、函数柯里化的实现。

```javascript
function curry(fn, ...args) {
  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);
}
```

##### 20、实现数据乱序输出。

```javascript
// 随机生成一个索引然后交换对应数据
var arr = [1,2,3,4,5,6,7,8,9,10];
for (var i = 0; i < arr.length; i++) {
  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;
  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];
}
```

##### 21、获取url参数。

```javascript
const getQueryByName = (name) => {
  const queryNameRegex = new RegExp(`[?&]${name}=([^&]*)(?:&|$)`);
  const queryNameMatch = window.location.search.match(queryNameRegex);
  // 一般都会通过decodeURIComponent解码处理
  return queryNameMatch ? decodeURIComponent(queryNameMatch[1]) : '';
}
```

##### 22、实现所有任务返回每个任务执行结果，并且每个任务具有原子性只能在两个任务之间中断，可暂停、恢复后继续执行任务。

```javascript
function processTask(...task) {
      let isRunning = false;
      let i = 0;
      let promiseResult = null; // 缓存任务执行结果
      const result = []; // 任务返回结果
      return {
        start() {
          return new Promise(async (resolve, reject) => {
            if (promiseResult) {
              // 执行失败或者执行完成
              promiseResult.then(resolve, reject);
            }
            if (isRunning) {
              return;
            }
            isRunning = true;
            while (i < task.length) {
              try {
                result.push(await task[i]());
              } catch (err) {
                isRunning = false;
                reject(err);
                promiseResult = Promise.reject(err);
              }
              i++;
              // 任务被中断
              if (!isRunning && i < task.length - 1) {
                return;
              }
            }
            isRunning = false;
            resolve(result);
            promiseResult = Promise.resolve(result);
          });
        },
        pause() {
          isRunning = false;
        },
      };
    }
```

#### 代码输出

```javascript
// 对象的属性只能是string、number、symbol
var a = { sex: "man" };
var b = { name: "name" };
var c = { age: "age" };

a[b] = 123; // 这里调用对象toString()方法将其转化为[object Object] a['[object Object]']
a[c] = 234; // a['[object Object]']
console.log(a[b]);
```

```javascript
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 }; // 因为 a = {n:2}，将a重新赋值了，所以a的指向变了，切断了与原对象之间的联系。
console.log(a.x); // undefined
console.log(b.x); // {n:2}
```
