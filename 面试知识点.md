[TOC]

### JavaScript

------

##### 数据类型

1. JavaScript有哪些数据类型，它们的区别？

   ```
   String、Number、Boolean、Null、Undefined、Symbol、Object。
   这些数据类型可分为基本数据类型和复杂数据类型。基本类型存储在栈(stack)中，而复杂数据类型则存储在堆中。这两种数据类型的区别其实就是堆栈的区别。
   栈：存放的是基本数据类型的值。数据结构为采用先进后出的队列。栈区内存由编译器自动释放。
   堆：存放的是复杂数据类型在栈中的引用地址。数据结构为采用先进先出的队列。堆区内存一般由开发者手动释放，如果开发者未释放，就由程序GC机制回收。
   ```

2. 数据类型的检测方式有哪些？

   ```
   typeof：检查数据的类型。
   instanceof：检查该对象是否在原型链上。
   Object.prototype.toString.call()：使用Object原型上的toString方法来检测基本类型。
   ```

3. isNaN和Number.isNaN函数的区别？

   ```
   两个方法都是用来判断是否不为Number类型。如果不是Number类型，返回true，反之则为false。
   isNaN：该方法对传入的参数会将其转化成Number类型，然后再去判断。
   Number.isNaN：该方法会对传入的参数判断是否为Number类型，不会进行数据的转化。然后再去判断。相比于isNaN判断更准确一点。

4. 为什么0.1 + 0.2 != 0.3，如何让其相等？

   ```
   计算机是通过二进制的方式存储值。0.1 + 0.2的和其实就是计算两个二进制数据之间的和。所以就造成了偏差。可以借助Number.EPSILON对象，该对象是设置一个误差范围，表示在该误差范围内是有效的。

5. JavaScript 中如何进行隐式类型转换？

   ```
   调用一个叫ToPrimitive(obj,type)的方法。首先判断数据类型是否为基本数据类型，如果是基本数据类型，则直接返回。如果不是，则根据该方法的type类型来返回。
   1、如果type为Number类型。首先调用valueOf方法，判断是否原始类型的值返回，如果有则返回。如果没有就调用toString方法，判断是否有值，有则返回，没有则抛出TypeError的异常。
   2、如果type为String类型。首先调用的是toString方法。逻辑同上。

6. Object.is() 与其他比较操作符 “==” 和 "===" 的区别？

   ```
   ==：简单比较数据值是否相等。
   ===：比较数据值是否相等的同时比较数据类型是否相等。
   Object.is()：和"==="判断类似。只不过判断+0与-0不相等。isNaN与isNaN是相等的。

##### JavaScript基础

1. new 操作符的实现原理。

   ```
   1、创建一个新对象。
   2、将新对象的_proto_属性设置为函数的原型对象。
   3、将构造函数的this指向该对象。并执行函数。
   4、判断函数返回值。如果函数返回的是引用类型，那么返回该对象。如果不是，那么就会创建的对象。

2. Map和Object、weakMap的区别？

   ```
   Map和Object都是采用键值对的方式存储数据。
   Map：属性可以是任意数据类型。读取属性的值，能够有序的属性的值。在频繁的删除或插入键值，Map是有做过性能优化。
   Object：属性只能是sttring和symbol类型。读取属性的值，是无序的，无法保证顺序。
   WeakMap:作用和Map差不多。但是WeakMap的键值只能是对象，且对对象是一种弱引用。当对象的其他引用被清除掉，WeakMap里面的键名和对应的对象会自动被删除，无需手动释放。
   ```

3. 对类数组对象的理解，如何转化成数组？

   ```
   一个拥有length属性和若干索引属性的对象称为类数组。类数组不能调用数组的方法。可以用过Array.From()方法将其转化为数组。

4. espace、encodeURI、encodeURIComponent区别？

   ```
   espace:会对传入的参数进行编码。如果只是字符串编码采用该方法。
   encodeURI和encodeURIComponent都是一种编码方式。只是encodeURIComponent编码范围比encodeURI更大。如果需要对整个URL编码，且需要使用该URL，那么就用encodeURI。如果需要对URL传参编码，那么就使用encodeURIComponent。

5. 对于Ajax的理解，实现一个Ajax请求。

   ```
   1、创建一个XMLHttpRequest对象xml。
   2、调用xml.open()方法。该方法提供请求类型以及请求地址。
   3、调用xml.send()方法。如果是post请求，send方法里面可以传递参数。
   4、监听onreadystatechange事件。当状态state为4且http状态码为200，表示请求已经完成且成功。然后可以进行其他逻辑性处理。
   ```

6. 对原型、原型链的理解。

   ```
   原型：JavaScript中的构造函数都会有一个prototype属性，该属性值就是构造函数的原型对象。该对象包含了构造函数所有共享的属性和方法。当通过构造函数创建实例时，实例中会有一个_proto_属性指向构造函数的原型对象。那么这个指针就成为原型。
   原型链：当我们访问对象上的某个属性时，会首先从其构造函数自身的属性上去查询是否有该属性，如果不存在，就去构造函数的原型对象上查找。而构造函数的原型对象可能继承了其他函数，这样一层一层的往上查找。如果查到就返回，否则就返回undefined。这样查找的过程称为原型链。

7. 对闭包的理解。

   ```
   闭包就是一个函数当中嵌套另外一个函数，并返回该函数。
   闭包的主要作用有两个。一个就是可以访问函数内部的变量的值。另外一个就是可以将函数变量的值保存在内存中。因为调用函数中还存在对闭包函数的引用，所以不会立即释放。但是过多使用闭包且不及时释放，有可能会导致内存泄漏。

8. 对作用域、作用域链的理解。

   ```
   作用域分为全局作用域和函数作用域。
   全局作用域：最外层的作用域。所有未定义直接赋值的变量自动声明为全局作用域。
   函数作用域：作用域是分层的，内层作用域可以访问外层作用域，反之不行。
   作用域链：在当前作用域中访问变量时，会从函数内部查找，查不到就往父级作用域中查找。直至到window对象。这样查找的过程就是作用域链。作用域链保证了执行环境对函数的权限访问和变量的有序访问。

9. 对执行上下文的理解。

   ```
   分为全局执行上下文、函数执行上下文、eval执行上下文。
   当函数代码被执行的时候，会创建一个全局执行上下文，并将全局上下文放到执行栈中。当遇到函数调用时，就会创建函数执行上下文，并将当前函数放到执行栈的顶部。当该函数执行完成后，就会从执行栈中弹出。直到所有代码都执行完毕，最后才将全局执行上下文中弹出。
   ```

10. 对this对象的理解。

    ```
    this是执行上下文中的一个属性。this指向分为以下几种情况。
    1、默认指向是window
    2、调用new关键字调用时，this指向创建的实例
    3、调用apply、call、bind等方法时，this指向传入的参数对象。
    4、调用对象属性里面的方法时，this指向该对象。

11. 实现call、apply、bind函数。

    ```
    实现call函数。
    1、判断参数是否为函数，如果不是函数就抛出异常
    2、判断是否有上下文对象，如果没有则设置为window
    3、获取传入参数
    4、将函数作为上下文对象的一个属性
    5、执行该上下文对象属性，并保存返回结果
    6、删除该属性
    7、返回结果
    apply和call实现原理差不多，只是传参不一样。bind函数只需要返回一个新的函数即可。

12. 浏览器垃圾回收机制。

13. 解释性语言和编译性语言的区别。

14. JavaScript执行过程是怎样的？

##### ES6

1. let、const、var的区别。

   ```
   var：存在变量提升，会导致相同名称的值被覆盖。
   let：不会存在变量提升。有块级作用域，在同一个块级作用域下，声明相同的变量，会报错。
   const：定义一个常量。作用和let差不多。如果定义的值是基本数据类型，那么该变量时不可被修改的。如果是复杂数据类型，对象里面的属性值是可以被修改的。因为const定义常量不变的是对对象引用的地址，而不是值不变。
   ```

2. 箭头函数和普通函数的区别？

   ```
   普通函数：1、能够使用new关键字来实例化对象。2、可以改变this的指向。
   箭头函数：1、不能作为构造函数使用 2、没有原型对象。3、this指向不会改变，即使使用apply、call、bind方法。

##### 异步编程

1. 异步编程的实现方式？

   ```
   1、函数回调方式。语法不够简洁，且会造成地狱回调。
   2、Promise。本质是上函数回调的升级版，只是改变回调的方式，通过使用then方法链式调用。如果嵌套请求层次过多，也会造成语义不明确，不便于调试。
   3、generator。通过控制函数的执行权的方式，来实现异步编程。当遇异步函数时，将函数执行权转交给异步函数，等到该函数执行完成，在将控制权收回，继续执行后面的代码。需要一个自执行机制。
   4、async/await。基于promise和generator实现的一种语法糖。当async函数遇到await关键字时，会等待await后面函数执行完成后，在继续执行后面的代码。
   ```

2. 对Promise的理解。

   ```
   Promise是一种异步解决方案。Promise有三个状态pending、resolve、reject。且只能从pending到resolve或pending到reject。一旦状态改变就不会改变。
   Promise有以下缺点。
   1、无法取消请求
   2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部

### Vue

------



### React

------



### 计算机网络

------



### 浏览器原理

------



### 前端工程化

------

