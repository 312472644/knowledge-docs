[TOC]

### JavaScript

------

##### 数据类型

1. JavaScript有哪些数据类型，它们的区别？

   ```
   String、Number、Boolean、Null、Undefined、Symbol、Object。
   这些数据类型可分为基本数据类型和复杂数据类型。基本类型存储在栈(stack)中，而复杂数据类型则存储在堆中。这两种数据类型的区别其实就是堆栈的区别。
   栈：存放的是基本数据类型的值。数据结构为采用先进后出的队列。栈区内存由编译器自动释放。
   堆：存放的是复杂数据类型在栈中的引用地址。数据结构为采用先进先出的队列。堆区内存一般由开发者手动释放，如果开发者未释放，就由程序GC机制回收。
   ```

2. 数据类型的检测方式有哪些？

   ```
   typeof：检查数据的类型。
   instanceof：检查该对象是否在原型链上。
   Object.prototype.toString.call()：使用Object原型上的toString方法来检测基本类型。
   ```

3. isNaN和Number.isNaN函数的区别？

   ```
   两个方法都是用来判断是否不为Number类型。如果不是Number类型，返回true，反之则为false。
   isNaN：该方法对传入的参数会将其转化成Number类型，然后再去判断。
   Number.isNaN：该方法会对传入的参数判断是否为Number类型，不会进行数据的转化。然后再去判断。相比于isNaN判断更准确一点。

4. 为什么0.1 + 0.2 != 0.3，如何让其相等？

   ```
   计算机是通过二进制的方式存储值。0.1 + 0.2的和其实就是计算两个二进制数据之间的和。所以就造成了偏差。可以借助Number.EPSILON对象，该对象是设置一个误差范围，表示在该误差范围内是有效的。

5. JavaScript 中如何进行隐式类型转换？

   ```
   调用一个叫ToPrimitive(obj,type)的方法。首先判断数据类型是否为基本数据类型，如果是基本数据类型，则直接返回。如果不是，则根据该方法的type类型来返回。
   1、如果type为Number类型。首先调用valueOf方法，判断是否原始类型的值返回，如果有则返回。如果没有就调用toString方法，判断是否有值，有则返回，没有则抛出TypeError的异常。
   2、如果type为String类型。首先调用的是toString方法。逻辑同上。

6. Object.is() 与其他比较操作符 “==” 和 "===" 的区别？

   ```
   ==：简单比较数据值是否相等。
   ===：比较数据值是否相等的同时比较数据类型是否相等。
   Object.is()：和"==="判断类似。只不过判断+0与-0不相等。isNaN与isNaN是相等的。

##### JavaScript基础

1. new 操作符的实现原理。

   ```
   1、创建一个新对象。
   2、将新对象的_proto_属性设置为函数的原型对象。
   3、将构造函数的this指向该对象。并执行函数。
   4、判断函数返回值。如果函数返回的是引用类型，那么返回该对象。如果不是，那么就会创建的对象。

2. Map和Object、weakMap的区别？

   ```
   Map和Object都是采用键值对的方式存储数据。
   Map：属性可以是任意数据类型。读取属性的值，能够有序的属性的值。在频繁的删除或插入键值，Map是有做过性能优化。
   Object：属性只能是sttring和symbol类型。读取属性的值，是无序的，无法保证顺序。
   WeakMap:作用和Map差不多。但是WeakMap的键值只能是对象，且对对象是一种弱引用。当对象的其他引用被清除掉，WeakMap里面的键名和对应的对象会自动被删除，无需手动释放。
   ```

3. 对类数组对象的理解，如何转化成数组？

   ```
   一个拥有length属性和若干索引属性的对象称为类数组。类数组不能调用数组的方法。可以用过Array.From()方法将其转化为数组。

4. espace、encodeURI、encodeURIComponent区别？

   ```
   espace:会对传入的参数进行编码。如果只是字符串编码采用该方法。
   encodeURI和encodeURIComponent都是一种编码方式。只是encodeURIComponent编码范围比encodeURI更大。如果需要对整个URL编码，且需要使用该URL，那么就用encodeURI。如果需要对URL传参编码，那么就使用encodeURIComponent。

5. 对于Ajax的理解，实现一个Ajax请求。

   ```
   1、创建一个XMLHttpRequest对象xml。
   2、调用xml.open()方法。该方法提供请求类型以及请求地址。
   3、调用xml.send()方法。如果是post请求，send方法里面可以传递参数。
   4、监听onreadystatechange事件。当状态state为4且http状态码为200，表示请求已经完成且成功。然后可以进行其他逻辑性处理。
   ```

6. 对原型、原型链的理解。

   ```
   原型：JavaScript中的构造函数都会有一个prototype属性，该属性值就是构造函数的原型对象。该对象包含了构造函数所有共享的属性和方法。当通过构造函数创建实例时，实例中会有一个_proto_属性指向构造函数的原型对象。那么这个指针就成为原型。
   原型链：当我们访问对象上的某个属性时，会首先从其构造函数自身的属性上去查询是否有该属性，如果不存在，就去构造函数的原型对象上查找。而构造函数的原型对象可能继承了其他函数，这样一层一层的往上查找。如果查到就返回，否则就返回undefined。这样查找的过程称为原型链。

7. 对闭包的理解。

   ```
   闭包就是一个函数当中嵌套另外一个函数，并返回该函数。
   闭包的主要作用有两个。一个就是可以访问函数内部的变量的值。另外一个就是可以将函数变量的值保存在内存中。因为调用函数中还存在对闭包函数的引用，所以不会立即释放。但是过多使用闭包且不及时释放，有可能会导致内存泄漏。

8. 对作用域、作用域链的理解。

   ```
   作用域分为全局作用域和函数作用域。
   全局作用域：最外层的作用域。所有未定义直接赋值的变量自动声明为全局作用域。
   函数作用域：作用域是分层的，内层作用域可以访问外层作用域，反之不行。
   作用域链：在当前作用域中访问变量时，会从函数内部查找，查不到就往父级作用域中查找。直至到window对象。这样查找的过程就是作用域链。作用域链保证了执行环境对函数的权限访问和变量的有序访问。

9. 对执行上下文的理解。

   ```
   分为全局执行上下文、函数执行上下文、eval执行上下文。每个上下文都包含了活动对象、作用域链、以及this对象。
   当函数代码被执行的时候，会创建一个全局执行上下文，并将全局上下文放到执行栈中。当遇到函数调用时，就会创建函数执行上下文，并将当前函数放到执行栈的顶部。当该函数执行完成后，就会从执行栈中弹出。直到所有代码都执行完毕，最后才将全局执行上下文中弹出。
   ```

10. 对this对象的理解。

    ```
    this是执行上下文中的一个属性。this指向分为以下几种情况。
    1、默认指向是window
    2、调用new关键字调用时，this指向创建的实例
    3、调用apply、call、bind等方法时，this指向传入的参数对象。
    4、调用对象属性里面的方法时，this指向该对象。

11. 实现call、apply、bind函数。

    ```
    实现call函数。
    1、判断参数是否为函数，如果不是函数就抛出异常
    2、判断是否有上下文对象，如果没有则设置为window
    3、获取传入参数
    4、将函数作为上下文对象的一个属性
    5、执行该上下文对象属性，并保存返回结果
    6、删除该属性
    7、返回结果
    apply和call实现原理差不多，只是传参不一样。bind函数只需要返回一个新的函数即可。

12. 浏览器垃圾回收机制。

    ```
    当JavaScript运行中，需要分配内存空间来存储变量和值。当变量不在参与运算后，就会被回收，以达到释放内存的目的。这就是垃圾回收。
    浏览器垃圾回收机制主要使用两种方式。
    1、清除标记。当变量进入执行环境时，就会打上一个标记(进入环境),表示当前变量正在使用，无法清除。当变量离开执行环境时，就会被标记为(离开环境)，离开环境的标记就自动被清除，并被内存释放。
    2、引用计数。跟踪记录每个值被引用的次数。当一个变量被赋值另外一个引用类型变量时，该值引用计数就会加1。相反，当该变量的值发生改变时，该值的引用计数就会减1。当该值引用计数变为0时，该值就会从内存中释放。

13. 解释性语言和编译性语言的区别。

    ```
    解释性语言：无法在机器上直接运行，需要由解释器将代码编译成机器码之后在执行。常见的解释性语言有JavaScript、Python等。每次执行代码都需要编译一次，执行效率相比于编译性语言要低一些。编译后直接在该平台运行，运行速度快。
    编译性语言：需要由编译器编译后，能在机器上直接运行。编译后的代码会生成一个可执行文件。如.exe等。以后要执行代码时，直接执行编译后的文件即可，无需每次编译。运行期间才编译，跨平台性好。

14. JavaScript执行过程是怎样的？

    ```
    执行过程可分为三个过程。
    1、词法拆分：将js代码拆分为字节流(token)，加入到一个AST数组中
    2、语法分析：分析AST数组，检查是否有语法错误。如果有错误，就抛出语法异常，没有就执行下一步
    3、代码生成：将AST转化成机器可执行的机器码，并执行代码

15. 前端模块化的理解。

    ```
    AMD：requireJS是基于该规范实现。依赖前置(提前加载)。依赖的函数会立即下载并运行，相对于seaJS用户体验更好。
    CMD：seaJS是基于该规范实现。就近依赖(按需加载)。依赖函数会下载，但不会立即执行，等到需要它的时候才会运行。相对于requireJS性能更好。
    CommonJS：node是基于该规范实现。是一个同步的加载模块。
    ES6：ES6模块语法。提供export和import导出和导入模块。

16. require和import的区别。

    ```
    1、require是CommonJS模块语法。import是ES6模块语法。
    2、require是运行时加载。import是编译时加载。
    3、require通过module.exports导出是一个模块对象。import通过export导出的是指定的代码。
    4、require通过module.exports的值不会发生改变(导出的是值的拷贝)。import通过export导出的值是会发生改变的(导出的值是引用类型)。
    ```
    
17. 为什么函数的arguments参数是类数组而不是数组？

    ```
    函数的arguments是一个对象，它的属性是从0开始依次递增的，有callee和length等属性，与数组相似；但是没有数组常见的属性。不能直接遍历。

18. requestAnimationFrame的理解。

    ```
    requestAnimationFrame是浏览器用于定时循环的一个接口。主要用于网页按帧重制。相比于setTimeout它具有以下有点。
    1、它会把每一帧中所有的DOM操作集中起来，在一次重绘或重排中完成。并且重绘或重排的时间紧跟浏览器的刷新频率。
    2、当页面未被激活时，页面的刷新机制也会被停止。当页面激活时，页面刷新机制会从上次暂停的地址继续开始。
    缺点：兼容性不好
    ```
    
19. 常见的函数式编程方法。

##### ES6

1. let、const、var的区别。

   ```
   var：存在变量提升，会导致相同名称的值被覆盖。
   let：不会存在变量提升。有块级作用域，在同一个块级作用域下，声明相同的变量，会报错。
   const：定义一个常量。作用和let差不多。如果定义的值是基本数据类型，那么该变量时不可被修改的。如果是复杂数据类型，对象里面的属性值是可以被修改的。因为const定义常量不变的是对对象引用的地址，而不是值不变。
   ```

2. 箭头函数和普通函数的区别？

   ```
   普通函数：1、能够使用new关键字来实例化对象。2、可以改变this的指向。
   箭头函数：1、不能作为构造函数使用 2、没有原型对象。3、this指向不会改变，即使使用apply、call、bind方法。

##### 异步编程

1. 异步编程的实现方式？

   ```
   1、函数回调方式。语法不够简洁，且会造成地狱回调。
   2、Promise。本质是上函数回调的升级版，只是改变回调的方式，通过使用then方法链式调用。如果嵌套请求层次过多，也会造成语义不明确，不便于调试。
   3、generator。通过控制函数的执行权的方式，来实现异步编程。当遇异步函数时，将函数执行权转交给异步函数，等到该函数执行完成，在将控制权收回，继续执行后面的代码。需要一个自执行机制。
   4、async/await。基于promise和generator实现的一种语法糖。当async函数遇到await关键字时，会等待await后面函数执行完成后，在继续执行后面的代码。
   ```

2. 对Promise的理解。

   ```
   Promise是一种异步解决方案。Promise有三个状态pending、resolve、reject。且只能从pending到resolve或pending到reject。一旦状态改变就不会改变。
   Promise有以下缺点。
   1、无法取消请求
   2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部

### Vue

------

##### Vue基础

1. Vue的基本原理。

   ```
   当创建一个实例时，Vue会遍历data中的属性，通过使用Object.defineProperty方法将data中的属性转化成getter/setter，并在内部记录相关依赖。每一个组件实例都有对应的watcher实例。当data中的属性值发生变化时，就会通知watcher实例，使其对应的组件更新。

2. 双向绑定的原理。

   ```
   采用数据劫持和发布订阅的设计模式。通过Object.defineProperty来劫持各属性的getter，setter，当数据发生改变时，会发送消息给订阅者，触发相应的回调。可以分为以下几个步骤。
   1、对需要监听的数据进行递归遍历，添加对应的getter和setter。
   2、complie解析模板指令，将每个指令进行解析，并添加对应的订阅者。
   3、组件对应的watcher实例充当订阅者的角色。当监听的数据属性值发生改变时，这时候就会触发setter或者getter方法，通知对应的订阅者，然后对应的组件进行更新。

3. MVVM、MVC的区别。

   ```
   MVC:M表示Model层，用来存储页面交互的数据。V表示View即视图层。C表示Controller即控制层，用来处理业务逻辑。用户通过View视图触发事件，通知Controller，然后Controller处理完成后，通知到Model，最后由Model层通知到View层，实现视图更新。
   MVVM：M表示数据模型层。用来定义数据模型。V表示视图层。VM是ViewModel。是用来链接Model层和View层的桥梁，当View层发生变化通过ViewModel也会引起Model层的改变。反之Model层改变也会通过ViewModel引起View的改变。

4. Computed、Watch、Methods的区别。

   ```
   Computed:计算属性。Computed的值具有缓存。只有当依赖的值发生变化时，才会重新执行。不支持异步。
   Watch:监听器。不具有缓存。当监听的数据发生改变时，会触发watch对象里面的方法进行回调操作。
   Methods:和计算属性差不多。但是Methods方法总是会调用执行。

5. slot作用以及原理。

   ```
   slot分为匿名插槽、具名插槽、作用插槽。
   匿名插槽：默认的插槽。
   具名插槽：通过指定slot的name属性，可以在指定的地方插入内容。
   作用插槽：通过将子组件的值传递父组件，以此来自定义插槽的渲染内容。
   当组件被vm实例化时，会生成一个vm.$slot的对象，该对象就是插槽对象。默认就是vm.$slot.default匿名插槽。具名插槽就是vm.$slot.name(定义的插槽name)。在视图渲染时，此时可以传递参数，这就是作用插槽。然后再slot对象替换成插槽的内容即可。

6. data为什么是一个函数而不是一个对象？

   ```
   为了解决数据混乱的问题。在组件内部，如果data是一个对象，当引用该组件改变data里面某个属性的值时，其他引用改组件的data值也会也会发生变化。如果是一个函数，就相当于是值引用，不会造成数据混乱的问题。

7. $nextTick原理及作用。

   ```
   $nextTick是利用promise、setTimeout等异步方法来模拟对应的宏/微任务的实现。用来实现异步队列的回调。它的作用就是某些场景需要进行DOM操作时，就使用该方法。引入异步队列的原因其实比较简单就是为了性能优化，如果是同步的话，对一个值多次赋值，会频繁的触发UI/DOM渲染，造成没必要的性能浪费。

8. 单页面(SPA)与多页面(MPA)的区别。

   ```
   SPA:单页面应用程序。只有一个主页面，所需的公共资源文件只需要加载一次。页面的跳转利是用前端路由跳转，因此页面是局部刷新的。用户体验好，但是不利于SEO。
   MPA:多页面应用程序。多个页面，每次页面跳转都会重复加载公共的资源文件，且会刷新页面，用户体验不好。但是利于SEO。
   ```

9. Vue data中某个一个属性值发生改变后，试图会立即更新吗？

   ```
   不会立即更新。Vue的DOM更新是异步的，只要监听到数据的变化，就会开启队列，并将其加入到队列中，同一个属性发生多次改变，只会添加一次进入队列(去重)。来达到性能优化的目的。等到下一次事件循环tick，就会执行去重后的代码。

10. 对React和Vue的理解，它们的异同。

    ```
    数据流：Vue双向数据流。React单向数据流。
    虚拟DOM：
    	Vue：当组件属性发生变化时，不需要渲染整个组件，只渲染改变部分。
    	React：当组件属性发生变化时，整个子组件会重新渲染。
    监听数据变化：
    	Vue：采用数据劫持-发布订阅的模式。
    	React：比较数据之间的引用是否发生改变，
    组件化：
    	Vue：template模板，更加贴近HTML原生写法。
    	React：JSX语法。
    ```

11. Vue 模板编译原理。

    ```
    分为三个阶段解析阶段、优化阶段、生成阶段。
    解析阶段：使用正则表达式将template转化成AST树。
    优化阶段：遍历AST树，对于静态节点打上标记，在diff算法中，打上静态标记直接跳过。
    生成阶段：将优化后的AST转化成render函数。
    ```
    
12. Vue的优缺点。

    ```
    优点：
    1、双向绑定
    2、提供响应式和组件化视图
    3、使用虚拟DOM
    4、轻量级框架
    缺点(相比于react):
    1、JSX与template。JSX语法可以使用完整的JS语法来构建页面。比如可以使用临时变量、条件控制语句等。
    2、原生渲染。React Native 相比于 week 更加成熟。
    ```
    
13. Vue 是如何收集依赖的？

    ```
    初始化vue组件实例时，会对组件中的data进行数据劫持，为每个data属性添加对应的getter/setter，其中getter部分就是用来收集依赖的。收集依赖主要有两个类Dep和Watcher。Dep类的主要作用是添加订阅者和发布消息，Watcher类作用就是收集相关依赖。每个组件都会有一个watcher实例，当实例化这个对象时，会触发构造函数中的get方法，该方法的作用就是将当前的watcher订阅到Dep的订阅列表中。当监听数据发生变化时,会触发Dep中的notify方法，然后通知对应的订阅者，实现对应的操作。

##### 生命周期

1. Vue生命周期有哪些。

   ```
   beforeCreated:组件实例创建之前。
   created:组件实例创建完成。此时渲染节点还未挂在到DOM，不能访问虚拟DOM。
   beforeMounted:开始挂载之前。render函数首次被调用，能够访问到虚拟DOM。
   mounted:挂载完成。将虚拟DOM替换成真实的DOM。可以访问到真实的DOM元素。
   beforeUpdate:组件更新之前。组件虽然更新了，但是真实的DOM还未被渲染。
   updated:更新完成。组件的DOM更新完成。
   beforeDestroy:组件销毁之前。能够访问到this对象，可以在此生命周期做一些释放对象内存的操作。
   destory:组件完成销毁。

##### 组件通信

1. 组件的通信方式有哪些。

   ```
   父传子：1、通过属性传递。2、父组件通过$ref获取子组件实例，同样子组件也可以通过$parent来获取父组件实例。
   子传父：子组件通过emit触发事件，父组件监听事件。
   跨组件传参：
   	1、事件总线。定义一个vue实例，触发事件，监听事件即可。
   	2、provider、inject
   	3、vuex store传递参数。

##### 路由

1. 路由hash和history模式的区别。

   ```
   hash：通过监听onhashchange事件去监听hash是否发生变化来实现对应的内容切换。hash值会出现在url里面，但是不会出现在http请求中，因此修改hash值不会重新加载页面。
   history：通过监听onpopstate事件来实现该路由。修改url，服务端会重新解析这个请求，因此服务端需要做一些配置。比如用户输入错误的地址，如果没有做出相应配置，那么页面就会报错了。
   ```

2. 路由的传参方式以及区别。

   ```
   1、query方式传参。通过$route.query获取。这种方式传参参数会出现在url中，刷新页面参数不会消失。
   2、param方式传参。通过$route.param获取。这种方式参数是通过body传递过去，不会出现在url中，刷新页面参数会丢失。

3. Vue-Router钩子有哪些？

   ```
   1、全局导航
   	beforeEach:进入路由之前。可以用该钩子实现登录拦截功能。
   	afterEach:进入路由之后。
   2、路由导航。
   	beforeEnter:如果不想配置全局导航，可以在路由导航里进行单独配置。
   3、组件导航。
   	beforeRouteEnter：进入组件之前触发的钩子。
   	beforeRouteLeave：离开组件触发钩子。
   	beforeRouteUpdate：路由改变时触发的钩子。比如路由参数发生变化等。
   ```

##### Vuex

1. Vuex的原理以及理解。

   ```
   vuex是一个状态管理的工具。其中vuex包含以下几个属性。
   state:用来定义store数据。
   commit：状态改变提交数据的方法。对mutation进行提交，是唯一能提交执行mutation的方法。
   mutation：Vuex推荐唯一能改变state数据的方法。该操作是同步的。
   action：支持异步操作改变state属性。action提交的是mutations，而不是直接改变状态。
   dispatch：操作行为方法。唯一能执行action的方法。
   getter：类似于computed属性，通过对state进行处理，返回处理后state数据。
   
   tips：可以通过mapState、mapGetter、mapMutation、mapAction来帮助我们调用vuex store。

2. Vuex和单纯的全局对象有什么区别？

   ```
   Veux是响应式。当store state里面的值发生改变时，视图也会做出响应的变化。而全局对象则不会。
   在非严格模式下是可以直接改变store的状态。但是这样会造成无法跟踪每一个状态的变化，当报错时，不便于调试。所以不推荐直接改变store的状态。

3. 为什么Vuex的mutation中不能做异步操作？

   ```
   Vuex改变状态的唯一途径都是mutation。异步操作Action也是通过提交mutation来改变状态。这样更加方便我们追踪每个状态的变化，便于调试。如果mutation支持异步操作，那么就无法区别是由Action 提交的mutation还是由commit提交mutation。

##### 虚拟DOM

1. 对虚拟DOM的理解？

   ```
   虚拟DOM其实就是一个JS对象，用来描述真实DOM结构的对象。配合不同渲染的工具，使跨平台具有可能性。通过处理事务机制(比如异步队列)，将多次的DOM修改的结果一次性渲染到页面上，而不用大量去操作DOM元素，引起不必要重绘和重排，提高性能。但是虚拟DOM的效率不一定比修改DOM要高，这个要看场景区分。比如只是修改一个div的文本信息，肯定是用直接操作DOM修改要快的，因为虚拟DOM还要经过Diff算法，才能渲染到页面上。
   缺点：无法进行极致优化。

2. 虚拟DOM解析过程。

   ```
   1、解析文档的DOM结构，用JS对象将其保存起来。
   2、当页面状态发生改变之后，根据改变后的状态，新建一个对象树，然后与之前的对象树进行比较。记录其差异。
   3、将其差异的对象树转化成真实DOM树。

3. Vue Diff算法的原理。

   ```
   1、不做跨级层次节点不做比较。
   2、如果父节点不同，则放弃比较子节点，直接删除旧节点然后添加新的节点重新渲染。
   3、如果子节点有变化，虚拟DOM不会计算变化时什么，而是重新渲染。
   4、同级多个节点比较通过唯一key比较异同。

4. Vue中key的作用。

   ```
   1、强制渲染。在v-if，如果切换的是相同类型的元素，那么这个元素就被复用。如果添加了key，这个元素就被标记为唯一，在此切换组件，就不会被复用了。
   2、提高虚拟DOM渲染效率。在v-for中使用key，相当于为每个元素添加了唯一标识。当数组发生改变，Diff算法直接通过key找到每个元素，而不用去遍历递归，从而提高虚拟DOM渲染效率。

### React

------

##### 组件基础

1. React的事件机制。

   ```
   React事件是合成事件，并不是将事件绑定给到真实的DOM上，而是在document上监听了所有事件，当事件冒泡至document时，React将事件内容交给真正的函数去处理。这样做的好处为了减少内存和在组件销毁的时候取消事件的订阅。冒泡至document事件不是原生事件，而是React的合成事件。使用合成事件的好处跨浏览器，统一事件处理机制。因此要阻止事件冒泡不能使用event.stopPropagation, 而是使用event.preventDefault。

2. 对React-Fiber的理解，它解决了什么问题？

   ```
   Fiber是React 16中新增的一种核心算法。它的作用支持虚拟DOM的增量渲染。在之前的版本中，渲染是，需要通过diff算法找出变动的节点，同步更新它们。这个过程React会占住浏览器资源，用户触发的事件得不到响应，会出现卡顿现象。所以React通过fiber，让这个过程变得可中断、暂停、继续，在适当的时候将控制权让给浏览器，让浏览器执行优先级更高的任务，等到浏览器空闲时，在恢复执行暂停的任务。这样浏览器就能及时响应用户的操作了，提高了用户的体验。

3. React.Compoent和React.PureComponent的区别。

   ```
   React.Compoent：表示一个组件。
   React.PureComponent：表示一个纯组件。它默认的执行了shouldUpdate生命周期，将数据进行浅比较，判断组件是否需要重新渲染。从而减少组件render的次数，达到提高组件性能的目的。
   ```

4. React 高阶组件是什么，和普通组件有什么区别，适用于什么场景？

   ```
   React高阶组件本质上是一个函数。通过将其他组件当参数传递进去，进行逻辑操作后，返回一个新的组件。
   HOC的好处：
   1、代码复用、逻辑抽象
   2、渲染劫持。比如可以通过HOC实现一个显示错误的组件，当页面报错，就会被该组件拦截，然后对错误信息进行处理。

5. 哪些方法会触发React重新渲染？重新渲染会做什么？

   ```
   1、调用setState方法。 调用setState会触发render函数，但是执行setState不一定会触发render，比如setState(null)时，就不会触发render。
   2、父组件重新渲染。只要父组件重新渲染，那么子组件全部会重新渲染，即使父组件传递给子组件参数未发生变化。
   重新渲染时会进行diff算法。首先会比较新旧VNode树，然后递归遍历新旧树，将其差异放入到一个对象中，最后遍历差异对象，根据规则去更新对应的VNode。

6. React如何判断什么时候渲染组件？

   ```
   组件可以通过改变props或通过setState方法来改变状态。只要组件的state发生变化，React就会重新渲染，这是因为shouldUpdate默认返回的是true。因此可以通过该生命周期来决定是否要渲染组件。
   ```

7. React中什么是受控组件和非受控组件。

   ```
   受控组件:表单元素的值需要React管理。比如Input输入框，React通过监听onChange事件，然后再去更新state的值。
   非受控组件:表单元素的值由自身去管理部依赖React。可以通过ref来获取表单的值。

8. 对React context的理解。

   ```
   context是React提供一种数据共享的方式，当我们需要跨层级传递参数可以使用该方式。通过Provider注入需要传递的参数，然后在需要组件的使用Consumer接受参数即可。React提供的Context对象就是就给子组件提供了一个作用域，而Context上的属性可以看成活动对象。所以组件可以通过Context访问到父组件链上所有节点提供的Context属性。但是当如果其中的一个中间件shouldUpdate返回的是false，那么其后面的组件将不在接受context的变化而触发render。

9. 类组件与函数组件有什么异同？

   ```
   相同点：组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素
   不同点：
   1、类组件面试对象编程。函数组件是函数式编程。
   2、类组件通过shouldUpdate优化性能。函数组件通过useMemo优化性能。
   3、如果需要使用生命周期，那么使用类组件。反之则使用函数组件。

##### 数据管理

1. React setState调用原理。

   ```
   当我们调用setState更新state时，并不会立即更新state的值，而是将新的state放入更新队列中，然后判断是否是批量更新，如果是批量更新，那么将其放入等待队列中等待下一次的批量更新。如果不是批量更新，则更新state的值，并渲染视图。

2. React setState调用之后发生了什么？是同步还是异步？

   ```
   在代码中调用setState方法后，React会将传入参数与当前组将状态合并，然后进行diff算法，比较新旧树的差异，并自动记录其差异。如果在短时间内频繁setState，eact会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。
   setState同/异步是根据场景而决定的。
   异步场景：在React可以控制的地方。比如React在生命周期和合成事件中，都会走合并策略，延迟执行。
   同步场景：在 React 无法控制的地方，比如原生事件，如setTimeout等。

3. 在React组件的this.state和setState有什么区别。

   ```
   setState本质是通过一个队列机制实现state更新的。用setState时，会将修改的state放入到队列中。出于性能考虑，多次的setState调用，最后会合并成一次调用。而this.state其本质没有将修改放入队列中，所以也不触发render。
   ```

##### 生命周期

1. React的生命周期有哪些？

   ```
   React生命周期分为三个阶段。
   1、装载阶段。
   2、更新阶段。
   3、卸载阶段。
   componentWillMount:在render之前执行。
   componentDidMount:组件挂载完成后。用来获取网络数据，执行DOM操作等。
   componentWillUpdate:组件更新之前。
   componentShouldUpdate:组件是否应该更新，可以通过返回true或false，来决定是否渲染组件。
   componentDidUpdate:组件更新完成。
   componentWillUnmount:组件将要卸载。可以用来取消事件的订阅或者释放内存。
   componentDidCatch:组件发生错误时，出触发该生命周期。可以用来捕获异常信息。
   tips：现在都推荐函数组件加hooks的写法了，因此生命周期可以被忽略了。

##### 组件通信

1. 组件之间的通信方式有哪些？

   ```
   父组件向子组件通信：通过props参数传递。
   子组件向父组件通信：通过props+回调函数。
   跨级组件的通信方式：1、利用第三方组件库，如mobx。2、利用Context。3、利用自定义事件通信。
   ```

##### 路由

1. React-Router的实现原理是什么？

   ```
   同Vue-Router。

2. React-Router的路由有几种模式？

   ```
   broswerHistory、hashHistory。

3. React-Router如何获取参数？

   ```
   1、get传值。通过正则去解析url里面的参数。
   2、动态路由传值。可以通过match.参数名或hook useParam获取。
   3、query或state传值。location.state或location.query获取。但是存在缺点就是只要刷新页面，参数就会丢失。

4. React-Router在怎样在路由变化时重新渲染同一个组件。

   ```
   监听componentWillReceiveProps生命周期。

##### Hooks

1. React Hook实现原理是什么？

   ```
   当函数组件第一次渲染执行上下文是，每个reack hooks执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上，然后react hooks的状态，绑定在当前hooks对象的memoizedState属性上。对于effect副作用钩子，会绑定在workInProgress.updateQueue(保存待更新队列)上，等到commit阶段，dom构建完成，在执行每个effect副作用钩子。
   tips:hooks 主要属性
   hooks = {
   	baseState,//初始值,
   	memoizedState,//hook state信息
   	queue,//待更新队列
   	baseQueue,//最新更新队列
   	next,//链表指针
   }

2. 为什么useState要使用数组而不是对象？

   ```
   如果返回的是对象，结构时必须要和useState内部实现返回的名称同名，想要使用多次，必须设置别名。返回数组则不会有这样的问题。

3. React Hooks解决了哪些问题？

   ```
   1、能够从组件中提取状态逻辑和将组件拆分成更小的颗粒度，使得这些逻辑可以单独测试复用。
   2、类组件语法有些冗余，且需要理解this指向问题。Hooks结合函数式组件使得语法更加简洁明了。

4. useEffect 与 useLayoutEffect的区别。

   ```
   共同点：用来处理副作用。包括数据的请求，事件订阅，DOM操作等。
   不同点：
   useLayoutEffect 是在所有DOM变更之后会同步调用，主要用来操作DOM(先改变DOM后渲染)，且不会造成页面闪烁。useEffect是异步调用的，当用来操作DOM时，可能会造成屏幕闪烁(先渲染，在改变DOM)。

5. 为什么不能在条件语句中调用 Hook 呢？

   ```
   在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。

##### 虚拟DOM

1. React diff算法原理是什么？

   ```
   Diff算法通过比较新旧树的差异，将更新的补丁作用于真实的DOM。React diff 从三个策略进行复杂度的优化。
   基于树组件对比：忽略节点跨层级操作场景。对比同一层级节点，如果发现该节点不存在，那么就会直接删除该节点，而不用继续去比较其子节点。
   基于组件对比：如果组件类型一致，则默认相似结构。反之，则为不同的结构。如果组件是同一类型，就会进行对比，如果不是则放入补丁中。
   基于节点对比：同一层级的子节点，可以通过key的方式进行列表对比。元素对比发生在同层级中，通过标记节点的方式操作补丁。节点的操作包括插入、移动、删除等。而React可以标记key来追踪被修改的元素，直接对这些元素进行操作，需要遍历递归，从而比较提高效率。

2. React key 是干嘛用的？

   ```
   key的作用就是用来追踪哪些元素被修改、删除、移动等。在比较新旧树差异时，无需递归比较整棵树，只需要比较被标记元素即可，提高效率。

3. React 与Vue的diff算法有何不同？

   ```
   相同点：
   1、不做跨层级节点比较
   2、通过key提升diff效率
   不同点：
   1、Vue进行diff时，调用patch函数，一边比较一边给真实DOM打补丁。
   2、Vue点的列表对比，采用的是中间到两端，React列表对比则是从左往右依次对比。
   3、Vue对比节点是，当节点类型相同时，如果className不同，则认为是不同的元素类型，删除重新创建。而React则认为是同类型节点，进行修改操作。
   ```

##### 其他

1. React状态提升是什么？使用场景有哪些？

   ```
   多个组件需要共享的状态提升到它们最近的父组件上，然后由父组件通过属性的形式分发给各个子组件。
   ```

2. 为什么React要用JSX？

   ```
   JSX是JavaScript的语法扩展。一种类似于XML的数据结构。XML在数据结构描述更具有可读性。且JSX语法可以使用完整的JS语法来构建页面。比如可以使用临时变量、条件控制语句等。
   ```

3. React设计思路，它的理念是什么？

   ```
   1、编写直观的代码
   2、简化可复用的组件
   3、Virtual DOM
   4、函数时编程
   ```
   
4. useState更新相同的State,函数组件执行2次？

   ```
   函数组件渲染是通过workInProgress内存树和current渲树来实现的。两棵树之间通过alternate属性关联起来的。
   当第一次渲染时，树A不存在alternate属性，所以就将树A直接复制一份当做workInProgress称为树B。所有的操作都在树B中进行，当state值更新后，以树B渲染。渲染完成后。树A和树B通过alertnate互相指向。此时树B作为下一次current树。
   第二次调用是，current树的值已经是更新后的值，而workInProgress内存树还是初始值，两棵树的baseState不一致，因此组件就会重新渲染一次。

### 计算机网络

------



### 浏览器原理

------



### 前端工程化

------

