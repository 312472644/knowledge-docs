[TOC]

### JavaScript

------

##### 数据类型

1. JavaScript有哪些数据类型，它们的区别？

   ```
   String、Number、Boolean、Null、Undefined、Symbol、Object。
   这些数据类型可分为基本数据类型和复杂数据类型。基本类型存储在栈(stack)中，而复杂数据类型则存储在堆中。这两种数据类型的区别其实就是堆栈的区别。
   栈：存放的是基本数据类型的值。数据结构为采用先进后出的队列。栈区内存由编译器自动释放。
   堆：存放的是复杂数据类型在栈中的引用地址。数据结构为采用先进先出的队列。堆区内存一般由开发者手动释放，如果开发者未释放，就由程序GC机制回收。
   ```

2. 数据类型的检测方式有哪些？

   ```
   typeof：检查数据的类型。
   instanceof：检查该对象是否在原型链上。
   Object.prototype.toString.call()：使用Object原型上的toString方法来检测基本类型。
   ```

3. isNaN和Number.isNaN函数的区别？

   ```
   两个方法都是用来判断是否不为Number类型。如果不是Number类型，返回true，反之则为false。
   isNaN：该方法对传入的参数会将其转化成Number类型，然后再去判断。
   Number.isNaN：该方法会对传入的参数判断是否为Number类型，不会进行数据的转化。然后再去判断。相比于isNaN判断更准确一点。

4. 为什么0.1 + 0.2 != 0.3，如何让其相等？

   ```
   计算机是通过二进制的方式存储值。0.1 + 0.2的和其实就是计算两个二进制数据之间的和。所以就造成了偏差。可以借助Number.EPSILON对象，该对象是设置一个误差范围，表示在该误差范围内是有效的。

5. JavaScript 中如何进行隐式类型转换？

   ```
   调用一个叫ToPrimitive(obj,type)的方法。首先判断数据类型是否为基本数据类型，如果是基本数据类型，则直接返回。如果不是，则根据该方法的type类型来返回。
   1、如果type为Number类型。首先调用valueOf方法，判断是否原始类型的值返回，如果有则返回。如果没有就调用toString方法，判断是否有值，有则返回，没有则抛出TypeError的异常。
   2、如果type为String类型。首先调用的是toString方法。逻辑同上。

6. Object.is() 与其他比较操作符 “==” 和 "===" 的区别？

   ```
   ==：简单比较数据值是否相等。
   ===：比较数据值是否相等的同时比较数据类型是否相等。
   Object.is()：和"==="判断类似。只不过判断+0与-0不相等。isNaN与isNaN是相等的。

##### JavaScript基础

1. new 操作符的实现原理。

   ```
   1、创建一个新对象。
   2、将新对象的_proto_属性设置为函数的原型对象。
   3、将构造函数的this指向该对象。并执行函数。
   4、判断函数返回值。如果函数返回的是引用类型，那么返回该对象。如果不是，那么就会创建的对象。

2. Map和Object、weakMap的区别？

   ```
   Map和Object都是采用键值对的方式存储数据。
   Map：属性可以是任意数据类型。读取属性的值，能够有序的属性的值。在频繁的删除或插入键值，Map是有做过性能优化。
   Object：属性只能是sttring和symbol类型。读取属性的值，是无序的，无法保证顺序。
   WeakMap:作用和Map差不多。但是WeakMap的键值只能是对象，且对对象是一种弱引用。当对象的其他引用被清除掉，WeakMap里面的键名和对应的对象会自动被删除，无需手动释放。
   ```

3. 对类数组对象的理解，如何转化成数组？

   ```
   一个拥有length属性和若干索引属性的对象称为类数组。类数组不能调用数组的方法。可以用过Array.From()方法将其转化为数组。

4. espace、encodeURI、encodeURIComponent区别？

   ```
   espace:会对传入的参数进行编码。如果只是字符串编码采用该方法。
   encodeURI和encodeURIComponent都是一种编码方式。只是encodeURIComponent编码范围比encodeURI更大。如果需要对整个URL编码，且需要使用该URL，那么就用encodeURI。如果需要对URL传参编码，那么就使用encodeURIComponent。

5. 对于Ajax的理解，实现一个Ajax请求。

   ```
   1、创建一个XMLHttpRequest对象xml。
   2、调用xml.open()方法。该方法提供请求类型以及请求地址。
   3、调用xml.send()方法。如果是post请求，send方法里面可以传递参数。
   4、监听onreadystatechange事件。当状态state为4且http状态码为200，表示请求已经完成且成功。然后可以进行其他逻辑性处理。
   ```

6. 对原型、原型链的理解。

   ```
   原型：JavaScript中的构造函数都会有一个prototype属性，该属性值就是构造函数的原型对象。该对象包含了构造函数所有共享的属性和方法。当通过构造函数创建实例时，实例中会有一个_proto_属性指向构造函数的原型对象。那么这个指针就成为原型。
   原型链：当我们访问对象上的某个属性时，会首先从其构造函数自身的属性上去查询是否有该属性，如果不存在，就去构造函数的原型对象上查找。而构造函数的原型对象可能继承了其他函数，这样一层一层的往上查找。如果查到就返回，否则就返回undefined。这样查找的过程称为原型链。

7. 对闭包的理解。

   ```
   闭包就是一个函数当中嵌套另外一个函数，并返回该函数。
   闭包的主要作用有两个。一个就是可以访问函数内部的变量的值。另外一个就是可以将函数变量的值保存在内存中。因为调用函数中还存在对闭包函数的引用，所以不会立即释放。但是过多使用闭包且不及时释放，有可能会导致内存泄漏。

8. 对作用域、作用域链的理解。

   ```
   作用域分为全局作用域和函数作用域。
   全局作用域：最外层的作用域。所有未定义直接赋值的变量自动声明为全局作用域。
   函数作用域：作用域是分层的，内层作用域可以访问外层作用域，反之不行。
   作用域链：在当前作用域中访问变量时，会从函数内部查找，查不到就往父级作用域中查找。直至到window对象。这样查找的过程就是作用域链。作用域链保证了执行环境对函数的权限访问和变量的有序访问。

9. 对执行上下文的理解。

   ```
   分为全局执行上下文、函数执行上下文、eval执行上下文。
   当函数代码被执行的时候，会创建一个全局执行上下文，并将全局上下文放到执行栈中。当遇到函数调用时，就会创建函数执行上下文，并将当前函数放到执行栈的顶部。当该函数执行完成后，就会从执行栈中弹出。直到所有代码都执行完毕，最后才将全局执行上下文中弹出。
   ```

10. 对this对象的理解。

    ```
    this是执行上下文中的一个属性。this指向分为以下几种情况。
    1、默认指向是window
    2、调用new关键字调用时，this指向创建的实例
    3、调用apply、call、bind等方法时，this指向传入的参数对象。
    4、调用对象属性里面的方法时，this指向该对象。

11. 实现call、apply、bind函数。

    ```
    实现call函数。
    1、判断参数是否为函数，如果不是函数就抛出异常
    2、判断是否有上下文对象，如果没有则设置为window
    3、获取传入参数
    4、将函数作为上下文对象的一个属性
    5、执行该上下文对象属性，并保存返回结果
    6、删除该属性
    7、返回结果
    apply和call实现原理差不多，只是传参不一样。bind函数只需要返回一个新的函数即可。

12. 浏览器垃圾回收机制。

    ```
    当JavaScript运行中，需要分配内存空间来存储变量和值。当变量不在参与运算后，就会被回收，以达到释放内存的目的。这就是垃圾回收。
    浏览器垃圾回收机制主要使用两种方式。
    1、清除标记。当变量进入执行环境时，就会打上一个标记(进入环境),表示当前变量正在使用，无法清除。当变量离开执行环境时，就会被标记为(离开环境)，离开环境的标记就自动被清除，并被内存释放。
    2、引用计数。跟踪记录每个值被引用的次数。当一个变量被赋值另外一个引用类型变量时，该值引用计数就会加1。相反，当该变量的值发生改变时，该值的引用计数就会减1。当该值引用计数变为0时，该值就会从内存中释放。

13. 解释性语言和编译性语言的区别。

    ```
    解释性语言：无法在机器上直接运行，需要由解释器将代码编译成机器码之后在执行。常见的解释性语言有JavaScript、Python等。每次执行代码都需要编译一次，执行效率相比于编译性语言要低一些。编译后直接在该平台运行，运行速度快。
    编译性语言：需要由编译器编译后，能在机器上直接运行。编译后的代码会生成一个可执行文件。如.exe等。以后要执行代码时，直接执行编译后的文件即可，无需每次编译。运行期间才编译，跨平台性好。

14. JavaScript执行过程是怎样的？

    ```
    执行过程可分为三个过程。
    1、词法拆分：将js代码拆分为字节流(token)，加入到一个AST数组中
    2、语法分析：分析AST数组，检查是否有语法错误。如果有错误，就抛出语法异常，没有就执行下一步
    3、代码生成：将AST转化成机器可执行的机器码，并执行代码

15. 前端模块化的理解。

    ```
    AMD：requireJS是基于该规范实现。依赖前置(提前加载)。依赖的函数会立即下载并运行，相对于seaJS用户体验更好。
    CMD：seaJS是基于该规范实现。就近依赖(按需加载)。依赖函数会下载，但不会立即执行，等到需要它的时候才会运行。相对于requireJS性能更好。
    CommonJS：node是基于该规范实现。是一个同步的加载模块。
    ES6：ES6模块语法。提供export和import导出和导入模块。

16. require和import的区别。

    ```
    1、require是CommonJS模块语法。import是ES6模块语法。
    2、require是运行时加载。import是编译时加载。
    3、require通过module.exports导出是一个模块对象。import通过export导出的是指定的代码。
    4、require通过module.exports的值不会发生改变(导出的是值的拷贝)。import通过export导出的值是会发生改变的(导出的值是引用类型)。

##### ES6

1. let、const、var的区别。

   ```
   var：存在变量提升，会导致相同名称的值被覆盖。
   let：不会存在变量提升。有块级作用域，在同一个块级作用域下，声明相同的变量，会报错。
   const：定义一个常量。作用和let差不多。如果定义的值是基本数据类型，那么该变量时不可被修改的。如果是复杂数据类型，对象里面的属性值是可以被修改的。因为const定义常量不变的是对对象引用的地址，而不是值不变。
   ```

2. 箭头函数和普通函数的区别？

   ```
   普通函数：1、能够使用new关键字来实例化对象。2、可以改变this的指向。
   箭头函数：1、不能作为构造函数使用 2、没有原型对象。3、this指向不会改变，即使使用apply、call、bind方法。

##### 异步编程

1. 异步编程的实现方式？

   ```
   1、函数回调方式。语法不够简洁，且会造成地狱回调。
   2、Promise。本质是上函数回调的升级版，只是改变回调的方式，通过使用then方法链式调用。如果嵌套请求层次过多，也会造成语义不明确，不便于调试。
   3、generator。通过控制函数的执行权的方式，来实现异步编程。当遇异步函数时，将函数执行权转交给异步函数，等到该函数执行完成，在将控制权收回，继续执行后面的代码。需要一个自执行机制。
   4、async/await。基于promise和generator实现的一种语法糖。当async函数遇到await关键字时，会等待await后面函数执行完成后，在继续执行后面的代码。
   ```

2. 对Promise的理解。

   ```
   Promise是一种异步解决方案。Promise有三个状态pending、resolve、reject。且只能从pending到resolve或pending到reject。一旦状态改变就不会改变。
   Promise有以下缺点。
   1、无法取消请求
   2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部

### Vue

------

##### Vue基础

1. Vue的基本原理。
2. 双向绑定的原理。
3. MVVM、MVC的区别。
4. Computed、Watch、Methods的区别。
5. slot作用以及原理。
6. data为什么是一个函数而不是一个对象？
7. $nextTick原理及作用。
8. 单页面(SPA)与多页面(MPA)的区别。
9. Vue template 到 render的过程。
10. Vue data中某个一个属性值发生改变后，试图会立即更新吗？
11. 对React和Vue的理解，它们的异同。
12. vue如何监听对象或者数组的某个属性的变化
13. Vue 模板编译原理

##### 生命周期

1. Vue生命周期有哪些。

##### 组件通信

1. 组件的通信方式有哪些。

##### 路由

1. 路由hash和history模式的区别。
2. 如何获取页面的hash变化？
3. 路由的传参方式以及区别。
4. Vue导航有哪些？
5. 对前端路由的理解。

##### Vuex

1. Vuex的原理以及理解。
2. Vuex和单纯的全局对象有什么区别？
3. 为什么Vuex的mutation中不能做异步操作？

##### 虚拟DOM

1. 对虚拟DOM的理解？
2. Diff算法的原理。
3. Vue中key的作用。

### React

------

##### 组件基础

1. React的事件机制。
2. 对React-Fiber的理解，它解决了什么问题？
3. React.Compoent和React.PureComponent的区别。
4. React 高阶组件是什么，和普通组件有什么区别，适用于什么场景？
5. 哪些方法会触发React重新渲染？重新渲染会做什么？
6. React如何判断什么时候渲染组件？
7. 有状态组件和无状态组件的理解及使用场景
8. React如何获取组件对应的DOM元素。
9. React中什么事受控组件和非受控组件。
10. 对React context的理解。
11. 类组件与函数组件有什么异同？

##### 数据管理

1. React setState调用原理。
2. React setState调用之后发生了什么？是同步还是异步？
3. 在React组件的this.state和setState有什么区别。
4. React组件的state和prop有什么区别？

##### 生命周期

1. React的生命周期有哪些？

##### 组件通信

1. 组件之间的通信方式有哪些？

##### 其他

1. React状态提升是什么？使用场景有哪些？
2. 为什么React要用JSX？
3. React设计思路，它的理念是什么？
4. React数据持久化有什么实践？

##### 路由

1. React-Router的实现原理是什么？
2. React-Router的路由有几种模式？
3. React-Router如何获取参数？
4. React-Router在怎样在路由变化时重新渲染同一个组件

##### Hooks

1. React Hook实现原理是什么？
2. 为什么useState要使用数组而不是对象？
3. React Hooks解决了哪些问题？
4. useEffect 与 useLayoutEffect的区别。

##### 虚拟DOM

1. React diff算法原理是什么？
2. React key 是干嘛用的？
3. 虚拟DOM的引入与直接操作原生DOM相比，哪一个效率更高，为什么？
4. React 与Vue的diff算法有何不同？

### 计算机网络

------



### 浏览器原理

------



### 前端工程化

------

